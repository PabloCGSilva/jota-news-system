[2025-07-09 21:33:36] === JOTA News System Test Results ===
[2025-07-09 21:33:36] Test execution started
[2025-07-09 21:33:36] Starting: Django Setup Verification
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 1 item

test_simple.py::test_django_setup PASSED                                 [100%]

============================== 1 passed in 0.60s ===============================
[2025-07-09 21:33:39] ✅ PASSED: Django Setup Verification
[2025-07-09 21:33:39] Starting: Database Connection
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 1 item

test_simple.py::test_database_connection PASSED                          [100%]

============================== 1 passed in 0.36s ===============================
[2025-07-09 21:33:42] ✅ PASSED: Database Connection
[2025-07-09 21:33:42] Starting: Basic Model Tests
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 3 items

test_simple.py::test_django_setup PASSED                                 [ 33%]
test_simple.py::test_category_model PASSED                               [ 66%]
test_simple.py::test_database_connection PASSED                          [100%]

============================== 3 passed in 0.77s ===============================
[2025-07-09 21:33:46] ✅ PASSED: Basic Model Tests
[2025-07-09 21:33:46] Starting: Authentication Tests (Fixed)
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 15 items

tests/test_authentication_fixed.py::TestUserModel::test_user_creation PASSED [  6%]
tests/test_authentication_fixed.py::TestUserModel::test_superuser_creation FAILED [ 13%]
tests/test_authentication_fixed.py::TestUserModel::test_user_profile_creation PASSED [ 20%]
tests/test_authentication_fixed.py::TestAPIKeyModel::test_api_key_creation PASSED [ 26%]
tests/test_authentication_fixed.py::TestAPIKeyModel::test_api_key_str FAILED [ 33%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_token_obtain PASSED [ 40%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_token_obtain_invalid_credentials PASSED [ 46%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_token_refresh PASSED [ 53%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_registration FAILED [ 60%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_profile_get FAILED [ 66%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_profile_update PASSED [ 73%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_unauthenticated_access PASSED [ 80%]
tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_api_key_authentication FAILED [ 86%]
tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_invalid_api_key PASSED [ 93%]
tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_inactive_api_key PASSED [100%]

=================================== FAILURES ===================================
____________________ TestUserModel.test_superuser_creation _____________________

self = <django.db.backends.utils.CursorWrapper object at 0x71712174f210>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$P45uE36q5Pe0jTZO71zc56$AJyjlUWp4sJc6+aJwFEPN3woGsgzbWJKHzH2XB0amss=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x71712174f210>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.test_authentication_fixed.TestUserModel object at 0x7171213acb50>

    def test_superuser_creation(self):
        """Test superuser can be created."""
>       admin = User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/test_authentication_fixed.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x71712174f210>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$P45uE36q5Pe0jTZO71zc56$AJyjlUWp4sJc6+aJwFEPN3woGsgzbWJKHzH2XB0amss=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x71712174f210>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_______________________ TestAPIKeyModel.test_api_key_str _______________________

self = <tests.test_authentication_fixed.TestAPIKeyModel object at 0x7171213adb10>
user = <User: test@example.com>

    def test_api_key_str(self, user):
        """Test API key string representation."""
        api_key = APIKey.objects.create(
            user=user,
            name='Test API Key',
            key='test-key-123'
        )
>       assert str(api_key) == 'Test API Key (test@example.com)'
E       AssertionError: assert 'Test API Key...t@example.com' == 'Test API Key...@example.com)'
E         - Test API Key (test@example.com)
E         ?              ^                -
E         + Test API Key - test@example.com
E         ?              ^^

tests/test_authentication_fixed.py:81: AssertionError
_________________ TestAuthenticationAPI.test_user_registration _________________

self = <tests.test_authentication_fixed.TestAuthenticationAPI object at 0x7171213afc50>
api_client = <rest_framework.test.APIClient object at 0x7170dbe50e10>

    def test_user_registration(self, api_client):
        """Test user registration."""
        url = reverse('auth:user_register')
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'newpass123',
            'first_name': 'New',
            'last_name': 'User'
        }
        response = api_client.post(url, data)
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response status_code=400, "application/json">.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests/test_authentication_fixed.py:139: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/auth/register/
INFO Request completed - POST /api/v1/auth/register/ - 400
WARNING Bad Request: /api/v1/auth/register/
_________________ TestAuthenticationAPI.test_user_profile_get __________________

self = <tests.test_authentication_fixed.TestAuthenticationAPI object at 0x717121398f10>
authenticated_client = <rest_framework.test.APIClient object at 0x7170dbe59550>
user = <User: test@example.com>

    def test_user_profile_get(self, authenticated_client, user):
        """Test getting user profile."""
        url = reverse('auth:user_profile')
        response = authenticated_client.get(url)
        assert response.status_code == status.HTTP_200_OK
>       assert response.data['email'] == user.email
E       KeyError: 'email'

tests/test_authentication_fixed.py:148: KeyError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/auth/profile/
INFO Request completed - GET /api/v1/auth/profile/ - 200
_____________ TestAPIKeyAuthentication.test_api_key_authentication _____________

self = <tests.test_authentication_fixed.TestAPIKeyAuthentication object at 0x71712139b410>
api_client = <rest_framework.test.APIClient object at 0x7170dbbbd350>
user = <User: test@example.com>
api_key = <APIKey: Test API Key - test@example.com>

    def test_api_key_authentication(self, api_client, user, api_key):
        """Test API key authentication works."""
        api_client.credentials(HTTP_AUTHORIZATION=f'Api-Key {api_key.key}')
        url = reverse('auth:user_profile')
        response = api_client.get(url)
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <Response status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/test_authentication_fixed.py:178: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/auth/profile/
INFO Request completed - GET /api/v1/auth/profile/ - 401
WARNING Unauthorized: /api/v1/auth/profile/
=========================== short test summary info ============================
FAILED tests/test_authentication_fixed.py::TestUserModel::test_superuser_creation
FAILED tests/test_authentication_fixed.py::TestAPIKeyModel::test_api_key_str
FAILED tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_registration
FAILED tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_profile_get
FAILED tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_api_key_authentication
========================= 5 failed, 10 passed in 5.80s =========================
[2025-07-09 21:33:55] ✅ PASSED: Authentication Tests (Fixed)
[2025-07-09 21:33:55] Starting: Unit Tests
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 37 items

tests/unit/test_classification_models.py::TestClassificationRule::test_create_classification_rule PASSED [  2%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_increment_matches PASSED [  5%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_increment_successful_classifications PASSED [  8%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_success_rate_calculation PASSED [ 10%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_unique_name PASSED [ 13%]
tests/unit/test_classification_models.py::TestClassificationModel::test_create_classification_model PASSED [ 16%]
tests/unit/test_classification_models.py::TestClassificationModel::test_model_increment_predictions PASSED [ 18%]
tests/unit/test_classification_models.py::TestClassificationResult::test_create_classification_result PASSED [ 21%]
tests/unit/test_classification_models.py::TestClassificationResult::test_accept_classification PASSED [ 24%]
tests/unit/test_classification_models.py::TestClassificationTrainingData::test_create_training_data PASSED [ 27%]
tests/unit/test_classification_models.py::TestClassificationStatistic::test_create_classification_statistic PASSED [ 29%]
tests/unit/test_classification_models.py::TestClassificationStatistic::test_statistic_success_rate_calculation PASSED [ 32%]
tests/unit/test_news_models.py::TestCategoryModel::test_create_category PASSED [ 35%]
tests/unit/test_news_models.py::TestCategoryModel::test_category_unique_name PASSED [ 37%]
tests/unit/test_news_models.py::TestCategoryModel::test_category_unique_slug PASSED [ 40%]
tests/unit/test_news_models.py::TestSubcategoryModel::test_create_subcategory PASSED [ 43%]
tests/unit/test_news_models.py::TestSubcategoryModel::test_subcategory_category_slug_unique_together PASSED [ 45%]
tests/unit/test_news_models.py::TestTagModel::test_create_tag PASSED     [ 48%]
tests/unit/test_news_models.py::TestTagModel::test_tag_unique_name PASSED [ 51%]
tests/unit/test_news_models.py::TestNewsModel::test_create_news PASSED   [ 54%]
tests/unit/test_news_models.py::TestNewsModel::test_news_auto_word_count PASSED [ 56%]
tests/unit/test_news_models.py::TestNewsModel::test_news_auto_reading_time PASSED [ 59%]
tests/unit/test_news_models.py::TestNewsModel::test_news_auto_summary_generation PASSED [ 62%]
tests/unit/test_news_models.py::TestNewsModel::test_news_increment_view_count PASSED [ 64%]
tests/unit/test_news_models.py::TestNewsModel::test_news_increment_share_count PASSED [ 67%]
tests/unit/test_news_models.py::TestNewsModel::test_news_external_id_unique PASSED [ 70%]
tests/unit/test_news_models.py::TestNewsProcessingLog::test_create_processing_log PASSED [ 72%]
tests/unit/test_news_serializers.py::TestCategorySerializer::test_serialize_category PASSED [ 75%]
tests/unit/test_news_serializers.py::TestCategorySerializer::test_deserialize_category PASSED [ 78%]
tests/unit/test_news_serializers.py::TestSubcategorySerializer::test_serialize_subcategory FAILED [ 81%]
tests/unit/test_news_serializers.py::TestTagSerializer::test_serialize_tag PASSED [ 83%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_list_serializer PASSED [ 86%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_detail_serializer PASSED [ 89%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_create_serializer PASSED [ 91%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_update_serializer PASSED [ 94%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_create_serializer_validation PASSED [ 97%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_create_with_duplicate_external_id PASSED [100%]

=================================== FAILURES ===================================
_____________ TestSubcategorySerializer.test_serialize_subcategory _____________

self = <tests.unit.test_news_serializers.TestSubcategorySerializer object at 0x7b0e3c991c10>
subcategory = <Subcategory: Test Category - Test Subcategory>

    def test_serialize_subcategory(self, subcategory):
        """Test serializing a subcategory."""
        serializer = SubcategorySerializer(subcategory)
        data = serializer.data
    
        assert data['name'] == subcategory.name
>       assert data['category'] == str(subcategory.category.id)
E       AssertionError: assert UUID('d519a85c-d9e6-4a7f-8562-7201a3683d4e') == 'd519a85c-d9e6-4a7f-8562-7201a3683d4e'
E        +  where 'd519a85c-d9e6-4a7f-8562-7201a3683d4e' = str(UUID('d519a85c-d9e6-4a7f-8562-7201a3683d4e'))
E        +    where UUID('d519a85c-d9e6-4a7f-8562-7201a3683d4e') = <Category: Test Category>.id
E        +      where <Category: Test Category> = <Subcategory: Test Category - Test Subcategory>.category

tests/unit/test_news_serializers.py:60: AssertionError
=============================== warnings summary ===============================
tests/unit/test_classification_models.py:14
  /app/tests/unit/test_classification_models.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:80
  /app/tests/unit/test_classification_models.py:80: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:119
  /app/tests/unit/test_classification_models.py:119: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:172
  /app/tests/unit/test_classification_models.py:172: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:196
  /app/tests/unit/test_classification_models.py:196: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:13
  /app/tests/unit/test_news_models.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:49
  /app/tests/unit/test_news_models.py:49: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:84
  /app/tests/unit/test_news_models.py:84: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:110
  /app/tests/unit/test_news_models.py:110: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:209
  /app/tests/unit/test_news_models.py:209: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:15
  /app/tests/unit/test_news_serializers.py:15: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:50
  /app/tests/unit/test_news_serializers.py:50: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:65
  /app/tests/unit/test_news_serializers.py:65: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:79
  /app/tests/unit/test_news_serializers.py:79: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/unit/test_news_serializers.py::TestSubcategorySerializer::test_serialize_subcategory
================== 1 failed, 36 passed, 14 warnings in 2.74s ===================
[2025-07-09 21:34:01] ✅ PASSED: Unit Tests
[2025-07-09 21:34:01] Starting: Integration Tests
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 32 items

tests/integration/test_news_api.py::TestNewsAPI::test_list_news_authenticated PASSED [  3%]
tests/integration/test_news_api.py::TestNewsAPI::test_list_news_unauthenticated FAILED [  6%]
tests/integration/test_news_api.py::TestNewsAPI::test_retrieve_news PASSED [  9%]
tests/integration/test_news_api.py::TestNewsAPI::test_create_news FAILED [ 12%]
tests/integration/test_news_api.py::TestNewsAPI::test_update_news PASSED [ 15%]
tests/integration/test_news_api.py::TestNewsAPI::test_filter_news_by_category ERROR [ 18%]
tests/integration/test_news_api.py::TestNewsAPI::test_search_news ERROR  [ 21%]
tests/integration/test_news_api.py::TestNewsAPI::test_mark_news_urgent PASSED [ 25%]
tests/integration/test_news_api.py::TestNewsAPI::test_share_news PASSED  [ 28%]
tests/integration/test_news_api.py::TestNewsAPI::test_get_related_news ERROR [ 31%]
tests/integration/test_news_api.py::TestNewsAPI::test_advanced_search ERROR [ 34%]
tests/integration/test_news_api.py::TestCategoryAPI::test_list_categories FAILED [ 37%]
tests/integration/test_news_api.py::TestCategoryAPI::test_create_category PASSED [ 40%]
tests/integration/test_news_api.py::TestCategoryAPI::test_category_statistics PASSED [ 43%]
tests/integration/test_news_api.py::TestTagAPI::test_list_tags PASSED    [ 46%]
tests/integration/test_news_api.py::TestTagAPI::test_create_tag PASSED   [ 50%]
tests/integration/test_news_api.py::TestNewsPermissions::test_unauthenticated_access_denied FAILED [ 53%]
tests/integration/test_news_api.py::TestNewsPermissions::test_read_only_access_for_regular_users PASSED [ 56%]
tests/integration/test_webhook_integration.py::TestWebhookEndpoints::test_webhook_source_crud PASSED [ 59%]
tests/integration/test_webhook_integration.py::TestWebhookEndpoints::test_webhook_statistics PASSED [ 62%]
tests/integration/test_webhook_integration.py::TestWebhookEndpoints::test_webhook_test_endpoint PASSED [ 65%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_valid_webhook FAILED [ 68%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_json FAILED [ 71%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_missing_required_fields FAILED [ 75%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_webhook_signature_verification FAILED [ 78%]
tests/integration/test_webhook_integration.py::TestWebhookDashboard::test_webhook_dashboard FAILED [ 81%]
tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_processing_task_triggered FAILED [ 84%]
tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_log_creation FAILED [ 87%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_source FAILED [ 90%]
tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_verification FAILED [ 93%]
tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_verification_invalid_token PASSED [ 96%]
tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_message_receive FAILED [100%]

==================================== ERRORS ====================================
__________ ERROR at setup of TestNewsAPI.test_filter_news_by_category __________

self = <django.db.backends.utils.CursorWrapper object at 0x789cac3890d0>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('b715bf8f-b34e-494a-8b8f-6bd4583b82cc'), datetime.datetime(2025, 7, 9, 21, 34, 8, 688658, tzinfo=datetime.timezo...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cac3890d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x789cac3890d0>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('b715bf8f-b34e-494a-8b8f-6bd4583b82cc'), datetime.datetime(2025, 7, 9, 21, 34, 8, 688658, tzinfo=datetime.timezo...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cac3890d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
________________ ERROR at setup of TestNewsAPI.test_search_news ________________

self = <django.db.backends.utils.CursorWrapper object at 0x789cac414ed0>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('b5bac7a1-d37d-46bf-9e5f-a4b2906ffc55'), datetime.datetime(2025, 7, 9, 21, 34, 9, 198682, tzinfo=datetime.timezo...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cac414ed0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x789cac414ed0>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('b5bac7a1-d37d-46bf-9e5f-a4b2906ffc55'), datetime.datetime(2025, 7, 9, 21, 34, 9, 198682, tzinfo=datetime.timezo...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cac414ed0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_____________ ERROR at setup of TestNewsAPI.test_get_related_news ______________

self = <django.db.backends.utils.CursorWrapper object at 0x789cac5717d0>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('f7e7efc2-8882-4e87-938a-ca4b0abb8b34'), datetime.datetime(2025, 7, 9, 21, 34, 10, 228645, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cac5717d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x789cac5717d0>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('f7e7efc2-8882-4e87-938a-ca4b0abb8b34'), datetime.datetime(2025, 7, 9, 21, 34, 10, 228645, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cac5717d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
______________ ERROR at setup of TestNewsAPI.test_advanced_search ______________

self = <django.db.backends.utils.CursorWrapper object at 0x789cabe77150>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('4095c8ca-0b74-4db4-a4b6-8a519956c4d3'), datetime.datetime(2025, 7, 9, 21, 34, 10, 731870, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cabe77150>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x789cabe77150>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('4095c8ca-0b74-4db4-a4b6-8a519956c4d3'), datetime.datetime(2025, 7, 9, 21, 34, 10, 731870, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x789cabe77150>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
=================================== FAILURES ===================================
__________________ TestNewsAPI.test_list_news_unauthenticated __________________

self = <tests.integration.test_news_api.TestNewsAPI object at 0x789cf175ced0>
api_client = <rest_framework.test.APIClient object at 0x789cf1b75410>
news = <News: Test News Article>

    def test_list_news_unauthenticated(self, api_client, news):
        """Test listing news without authentication."""
        url = reverse('news:news-list')
        response = api_client.get(url)
    
>       assert response.status_code == status.HTTP_401_UNAUTHORIZED
E       assert 200 == 401
E        +  where 200 = <Response status_code=200, "application/json">.status_code
E        +  and   401 = status.HTTP_401_UNAUTHORIZED

tests/integration/test_news_api.py:32: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/articles/
INFO Request completed - GET /api/v1/news/articles/ - 200
_________________________ TestNewsAPI.test_create_news _________________________

self = <tests.integration.test_news_api.TestNewsAPI object at 0x789cf175d590>
authenticated_client = <rest_framework.test.APIClient object at 0x789cac577090>
category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    def test_create_news(self, authenticated_client, category, subcategory):
        """Test creating news via API."""
        url = reverse('news:news-list')
        data = {
            'title': 'API Created News',
            'content': 'This news was created via API with sufficient content length.',
            'source': 'API Test',
            'author': 'Test Author',
            'category': str(category.id),
            'subcategory': str(subcategory.id),
            'tag_names': ['api', 'test'],
            'is_published': True
        }
    
        response = authenticated_client.post(url, data)
    
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['title'] == 'API Created News'
>       assert response.data['category'] == str(category.id)
E       AssertionError: assert UUID('0d3b7d83-9436-493d-945b-1bde0c19438b') == '0d3b7d83-9436-493d-945b-1bde0c19438b'
E        +  where '0d3b7d83-9436-493d-945b-1bde0c19438b' = str(UUID('0d3b7d83-9436-493d-945b-1bde0c19438b'))
E        +    where UUID('0d3b7d83-9436-493d-945b-1bde0c19438b') = <Category: Test Category>.id

tests/integration/test_news_api.py:63: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/news/articles/
INFO Request completed - POST /api/v1/news/articles/ - 201
_____________________ TestCategoryAPI.test_list_categories _____________________

self = <tests.integration.test_news_api.TestCategoryAPI object at 0x789cf174a7d0>
authenticated_client = <rest_framework.test.APIClient object at 0x789caba8b790>
category = <Category: Test Category>

    def test_list_categories(self, authenticated_client, category):
        """Test listing categories."""
        url = reverse('news:category-list')
        response = authenticated_client.get(url)
    
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) >= 1
    
>       category_data = response.data[0]
E       KeyError: 0

tests/integration/test_news_api.py:163: KeyError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/categories/
INFO Request completed - GET /api/v1/news/categories/ - 200
____________ TestNewsPermissions.test_unauthenticated_access_denied ____________

self = <tests.integration.test_news_api.TestNewsPermissions object at 0x789cf174b590>
api_client = <rest_framework.test.APIClient object at 0x789caba57dd0>
news = <News: Test News Article>

    def test_unauthenticated_access_denied(self, api_client, news):
        """Test that unauthenticated users can't access news API."""
        urls = [
            reverse('news:news-list'),
            reverse('news:news-detail', kwargs={'pk': news.id}),
            reverse('news:category-list'),
            reverse('news:tag-list'),
        ]
    
        for url in urls:
            response = api_client.get(url)
>           assert response.status_code == status.HTTP_401_UNAUTHORIZED
E           assert 200 == 401
E            +  where 200 = <Response status_code=200, "application/json">.status_code
E            +  and   401 = status.HTTP_401_UNAUTHORIZED

tests/integration/test_news_api.py:237: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/articles/
INFO Request completed - GET /api/v1/news/articles/ - 200
______________ TestNewsWebhookReceiver.test_receive_valid_webhook ______________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x789cf1f8ae90>
api_client = <rest_framework.test.APIClient object at 0x789cabea6d50>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': 'af19c177-4aa4-48d4-970d-c3e8fa1b8ff5', ...}
mock_celery = None

    def test_receive_valid_webhook(self, api_client, webhook_source, sample_webhook_data, mock_celery):
        """Test receiving a valid webhook."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:86: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
__________ TestNewsWebhookReceiver.test_receive_webhook_invalid_json ___________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x789cf1faad50>
api_client = <rest_framework.test.APIClient object at 0x789cac2c2490>
webhook_source = <WebhookSource: Test Webhook Source>

    def test_receive_webhook_invalid_json(self, api_client, webhook_source):
        """Test receiving webhook with invalid JSON."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data='invalid json',
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_400_BAD_REQUEST
E       assert 401 == 400
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   400 = status.HTTP_400_BAD_REQUEST

tests/integration/test_webhook_integration.py:115: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_____ TestNewsWebhookReceiver.test_receive_webhook_missing_required_fields _____

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x789cf1faa090>
api_client = <rest_framework.test.APIClient object at 0x789cac30c690>
webhook_source = <WebhookSource: Test Webhook Source>, mock_celery = None

    def test_receive_webhook_missing_required_fields(self, api_client, webhook_source, mock_celery):
        """Test receiving webhook with missing required fields."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        invalid_data = {
            'title': 'Test News',
            # Missing content, source
        }
    
        response = api_client.post(
            url,
            data=json.dumps(invalid_data),
            content_type='application/json'
        )
    
        # Should accept the webhook but validation will fail in processing
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:133: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_________ TestNewsWebhookReceiver.test_webhook_signature_verification __________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x789cf1fab090>
mock_verify = <MagicMock name='verify_webhook_signature' id='132615465491728'>
api_client = <rest_framework.test.APIClient object at 0x789cac5754d0>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': '8e6dbff1-6ae9-4b24-beb8-5a3a08e9219a', ...}

    @patch('apps.webhooks.utils.verify_webhook_signature')
    def test_webhook_signature_verification(self, mock_verify, api_client, webhook_source, sample_webhook_data):
        """Test webhook signature verification."""
        webhook_source.requires_authentication = True
        webhook_source.save()
    
        # Test with valid signature
        mock_verify.return_value = True
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json',
            HTTP_X_HUB_SIGNATURE_256='sha256=valid_signature'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:152: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Webhook source updated: Test Webhook Source
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
------------------------------ Captured log call -------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source updated: Test Webhook Source
_________________ TestWebhookDashboard.test_webhook_dashboard __________________

self = <tests.integration.test_webhook_integration.TestWebhookDashboard object at 0x789cf1b4ded0>
authenticated_client = <rest_framework.test.APIClient object at 0x789cac42e050>
webhook_source = <WebhookSource: Test Webhook Source>

    def test_webhook_dashboard(self, authenticated_client, webhook_source):
        """Test webhook dashboard endpoint."""
        url = reverse('webhooks:dashboard')
>       response = authenticated_client.get(url)

tests/integration/test_webhook_integration.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:289: in get
    response = super().get(path, data=data, **extra)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:206: in get
    return self.generic('GET', path, **r)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:234: in generic
    return super().generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:609: in generic
    return self.request(**r)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:286: in request
    return super().request(**kwargs)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:238: in request
    request = super().request(**kwargs)
/usr/local/lib/python3.11/site-packages/django/test/client.py:891: in request
    self.check_exception(response)
/usr/local/lib/python3.11/site-packages/django/test/client.py:738: in check_exception
    raise exc_value
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: in inner
    response = get_response(request)
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:197: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
/usr/local/lib/python3.11/site-packages/django/views/decorators/csrf.py:56: in wrapper_view
    return view_func(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/views/generic/base.py:104: in view
    return self.dispatch(request, *args, **kwargs)
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:509: in dispatch
    response = self.handle_exception(exc)
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:480: in raise_uncaught_exception
    raise exc
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
/usr/local/lib/python3.11/site-packages/rest_framework/decorators.py:50: in handler
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <rest_framework.request.Request: GET '/api/v1/webhooks/dashboard/'>

    @api_view(['GET'])
    @permission_classes([IsAuthenticated])
    @extend_schema(
        summary="Get webhook dashboard data",
        description="Get aggregated webhook statistics for dashboard display."
    )
    def webhook_dashboard(request):
        """
        Get webhook dashboard data.
        """
        # Get recent statistics
        today = timezone.now().date()
        week_ago = today - timezone.timedelta(days=7)
    
        # Overall statistics
        total_sources = WebhookSource.objects.filter(is_active=True).count()
        total_logs = WebhookLog.objects.filter(created_at__date__gte=week_ago).count()
        success_rate = WebhookLog.objects.filter(
            created_at__date__gte=week_ago,
            status='success'
        ).count() / max(total_logs, 1) * 100
    
        # Recent activity
        recent_logs = WebhookLog.objects.filter(
            created_at__date__gte=week_ago
        ).order_by('-created_at')[:10]
    
        # Source statistics
        source_stats = []
        for source in WebhookSource.objects.filter(is_active=True):
            stats = WebhookStatistic.objects.filter(
                source=source,
                date__gte=week_ago
            ).aggregate(
>               total_requests=models.Sum('total_requests'),
                successful_requests=models.Sum('successful_requests'),
                failed_requests=models.Sum('failed_requests')
            )
E           NameError: name 'models' is not defined

apps/webhooks/views.py:404: NameError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/webhooks/dashboard/
ERROR Request failed - GET /api/v1/webhooks/dashboard/ - name 'models' is not defined
Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py", line 197, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/decorators/csrf.py", line 56, in wrapper_view
    return view_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/generic/base.py", line 104, in view
    return self.dispatch(request, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 509, in dispatch
    response = self.handle_exception(exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 480, in raise_uncaught_exception
    raise exc
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/decorators.py", line 50, in handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/app/apps/webhooks/views.py", line 404, in webhook_dashboard
    total_requests=models.Sum('total_requests'),
                   ^^^^^^
NameError: name 'models' is not defined
ERROR Internal Server Error: /api/v1/webhooks/dashboard/
Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py", line 55, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py", line 197, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/decorators/csrf.py", line 56, in wrapper_view
    return view_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/generic/base.py", line 104, in view
    return self.dispatch(request, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 509, in dispatch
    response = self.handle_exception(exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 480, in raise_uncaught_exception
    raise exc
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/decorators.py", line 50, in handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/app/apps/webhooks/views.py", line 404, in webhook_dashboard
    total_requests=models.Sum('total_requests'),
                   ^^^^^^
NameError: name 'models' is not defined
INFO Request completed - GET /api/v1/webhooks/dashboard/ - 500
_________ TestWebhookProcessing.test_webhook_processing_task_triggered _________

self = <tests.integration.test_webhook_integration.TestWebhookProcessing object at 0x789cf1b4ffd0>
mock_task = <MagicMock name='delay' id='132614293714704'>
api_client = <rest_framework.test.APIClient object at 0x789cabde6dd0>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': '3bc80636-d7f2-412c-9318-fa1bcf8f1bcd', ...}

    @patch('apps.webhooks.tasks.process_webhook_async.delay')
    def test_webhook_processing_task_triggered(self, mock_task, api_client, webhook_source, sample_webhook_data):
        """Test that webhook processing task is triggered."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:273: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_______________ TestWebhookProcessing.test_webhook_log_creation ________________

self = <tests.integration.test_webhook_integration.TestWebhookProcessing object at 0x789cf1b4e550>
api_client = <rest_framework.test.APIClient object at 0x789cabb01ad0>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': 'd50f38d2-22a0-41ed-ad18-9f3429813d96', ...}
mock_celery = None

    def test_webhook_log_creation(self, api_client, webhook_source, sample_webhook_data, mock_celery):
        """Test that webhook logs are created properly."""
        initial_log_count = WebhookLog.objects.count()
    
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:290: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_________ TestNewsWebhookReceiver.test_receive_webhook_invalid_source __________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x789cf1f8b1d0>
api_client = <rest_framework.test.APIClient object at 0x789cac37b350>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': 'aa9cafd6-bdb1-43e1-9bef-f6d13ce292b4', ...}

    def test_receive_webhook_invalid_source(self, api_client, sample_webhook_data):
        """Test receiving webhook with invalid source."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': 'nonexistent'})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 500 == 404
E        +  where 500 = <JsonResponse status_code=500, "application/json">.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests/integration/test_webhook_integration.py:103: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/nonexistent/
ERROR Error processing webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 219, in news_webhook
    source = WebhookSource.objects.get(name=source_name, is_active=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
INFO Request completed - POST /api/v1/webhooks/receive/nonexistent/ - 500
ERROR Internal Server Error: /api/v1/webhooks/receive/nonexistent/
------------------------------ Captured log call -------------------------------
ERROR    apps.webhooks.views:views.py:290 Error processing webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 219, in news_webhook
    source = WebhookSource.objects.get(name=source_name, is_active=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
____________ TestWhatsAppWebhook.test_whatsapp_webhook_verification ____________

self = <tests.integration.test_webhook_integration.TestWhatsAppWebhook object at 0x789cf1fab9d0>
api_client = <rest_framework.test.APIClient object at 0x789cabd72450>

    def test_whatsapp_webhook_verification(self, api_client):
        """Test WhatsApp webhook verification."""
        url = reverse('webhooks:whatsapp_webhook')
    
        params = {
            'hub.mode': 'subscribe',
            'hub.challenge': 'test_challenge_string',
            'hub.verify_token': 'test_verify_token'
        }
    
        response = api_client.get(url, params)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 400 == 200
E        +  where 400 = <HttpResponse status_code=400, "text/html; charset=utf-8">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:183: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/webhooks/whatsapp/
INFO Request completed - GET /api/v1/webhooks/whatsapp/ - 400
WARNING Bad Request: /api/v1/webhooks/whatsapp/
__________ TestWhatsAppWebhook.test_whatsapp_webhook_message_receive ___________

self = <tests.integration.test_webhook_integration.TestWhatsAppWebhook object at 0x789cf1b4c350>
api_client = <rest_framework.test.APIClient object at 0x789cac9df4d0>

    def test_whatsapp_webhook_message_receive(self, api_client):
        """Test receiving WhatsApp messages."""
        url = reverse('webhooks:whatsapp_webhook')
    
        whatsapp_data = {
            'object': 'whatsapp_business_account',
            'entry': [{
                'id': 'entry_id',
                'changes': [{
                    'value': {
                        'messaging_product': 'whatsapp',
                        'metadata': {
                            'phone_number_id': 'phone_id'
                        },
                        'messages': [{
                            'id': 'message_id',
                            'from': '5511999999999',
                            'timestamp': '1234567890',
                            'text': {
                                'body': 'Hello from WhatsApp'
                            },
                            'type': 'text'
                        }]
                    },
                    'field': 'messages'
                }]
            }]
        }
    
        response = api_client.post(
            url,
            data=json.dumps(whatsapp_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 500 == 200
E        +  where 500 = <JsonResponse status_code=500, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:235: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/whatsapp/
ERROR Error processing WhatsApp webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 343, in whatsapp_webhook
    source=WebhookSource.objects.get_or_create(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 916, in get_or_create
    return self.get(**kwargs), False
           ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
INFO Request completed - POST /api/v1/webhooks/whatsapp/ - 500
ERROR Internal Server Error: /api/v1/webhooks/whatsapp/
------------------------------ Captured log call -------------------------------
ERROR    apps.webhooks.views:views.py:366 Error processing WhatsApp webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 343, in whatsapp_webhook
    source=WebhookSource.objects.get_or_create(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 916, in get_or_create
    return self.get(**kwargs), False
           ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
=============================== warnings summary ===============================
tests/integration/test_news_api.py:9
  /app/tests/integration/test_news_api.py:9: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_news_api.py:151
  /app/tests/integration/test_news_api.py:151: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_news_api.py:195
  /app/tests/integration/test_news_api.py:195: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_news_api.py:222
  /app/tests/integration/test_news_api.py:222: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:14
  /app/tests/integration/test_webhook_integration.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:72
  /app/tests/integration/test_webhook_integration.py:72: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:167
  /app/tests/integration/test_webhook_integration.py:167: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:238
  /app/tests/integration/test_webhook_integration.py:238: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:258
  /app/tests/integration/test_webhook_integration.py:258: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/integration/test_news_api.py::TestNewsAPI::test_list_news_unauthenticated
FAILED tests/integration/test_news_api.py::TestNewsAPI::test_create_news - As...
FAILED tests/integration/test_news_api.py::TestCategoryAPI::test_list_categories
FAILED tests/integration/test_news_api.py::TestNewsPermissions::test_unauthenticated_access_denied
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_valid_webhook
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_json
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_missing_required_fields
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_webhook_signature_verification
FAILED tests/integration/test_webhook_integration.py::TestWebhookDashboard::test_webhook_dashboard
FAILED tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_processing_task_triggered
FAILED tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_log_creation
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_source
FAILED tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_verification
FAILED tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_message_receive
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_filter_news_by_category
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_search_news - dja...
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_get_related_news
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_advanced_search
============= 14 failed, 14 passed, 9 warnings, 4 errors in 9.64s ==============
[2025-07-09 21:34:14] ✅ PASSED: Integration Tests
[2025-07-09 21:34:14] Starting: All Tests with Coverage
============================= test session starts ==============================
platform linux -- Python 3.11.13, pytest-7.4.3, pluggy-1.6.0 -- /usr/local/bin/python
cachedir: .pytest_cache
django: version: 4.2.7
rootdir: /app
configfile: pytest.ini
plugins: Faker-37.4.0, cov-4.1.0, django-4.7.0, anyio-4.9.0
collecting ... collected 138 items

tests/test_authentication.py::TestUserModel::test_user_creation PASSED   [  0%]
tests/test_authentication.py::TestUserModel::test_superuser_creation FAILED [  1%]
tests/test_authentication.py::TestUserModel::test_user_profile_creation PASSED [  2%]
tests/test_authentication.py::TestAPIKeyModel::test_api_key_creation PASSED [  2%]
tests/test_authentication.py::TestAPIKeyModel::test_api_key_str FAILED   [  3%]
tests/test_authentication.py::TestAuthenticationAPI::test_token_obtain PASSED [  4%]
tests/test_authentication.py::TestAuthenticationAPI::test_token_obtain_invalid_credentials PASSED [  5%]
tests/test_authentication.py::TestAuthenticationAPI::test_token_refresh PASSED [  5%]
tests/test_authentication.py::TestAuthenticationAPI::test_user_registration FAILED [  6%]
tests/test_authentication.py::TestAuthenticationAPI::test_user_profile_get FAILED [  7%]
tests/test_authentication.py::TestAuthenticationAPI::test_user_profile_update PASSED [  7%]
tests/test_authentication.py::TestAuthenticationAPI::test_unauthenticated_access PASSED [  8%]
tests/test_authentication.py::TestAPIKeyAuthentication::test_api_key_authentication FAILED [  9%]
tests/test_authentication.py::TestAPIKeyAuthentication::test_invalid_api_key PASSED [ 10%]
tests/test_authentication.py::TestAPIKeyAuthentication::test_inactive_api_key PASSED [ 10%]
tests/test_authentication_fixed.py::TestUserModel::test_user_creation PASSED [ 11%]
tests/test_authentication_fixed.py::TestUserModel::test_superuser_creation FAILED [ 12%]
tests/test_authentication_fixed.py::TestUserModel::test_user_profile_creation PASSED [ 13%]
tests/test_authentication_fixed.py::TestAPIKeyModel::test_api_key_creation PASSED [ 13%]
tests/test_authentication_fixed.py::TestAPIKeyModel::test_api_key_str FAILED [ 14%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_token_obtain PASSED [ 15%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_token_obtain_invalid_credentials PASSED [ 15%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_token_refresh PASSED [ 16%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_registration FAILED [ 17%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_profile_get FAILED [ 18%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_profile_update PASSED [ 18%]
tests/test_authentication_fixed.py::TestAuthenticationAPI::test_unauthenticated_access PASSED [ 19%]
tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_api_key_authentication FAILED [ 20%]
tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_invalid_api_key PASSED [ 21%]
tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_inactive_api_key PASSED [ 21%]
tests/test_news.py::TestNewsModel::test_news_creation PASSED             [ 22%]
tests/test_news.py::TestNewsModel::test_news_word_count_calculation PASSED [ 23%]
tests/test_news.py::TestNewsModel::test_news_reading_time_calculation PASSED [ 23%]
tests/test_news.py::TestCategoryModel::test_category_creation PASSED     [ 24%]
tests/test_news.py::TestCategoryModel::test_category_subcategories PASSED [ 25%]
tests/test_news.py::TestNewsAPI::test_news_list_public FAILED            [ 26%]
tests/test_news.py::TestNewsAPI::test_news_detail_public FAILED          [ 26%]
tests/test_news.py::TestNewsAPI::test_news_create_authenticated FAILED   [ 27%]
tests/test_news.py::TestNewsAPI::test_news_create_unauthenticated FAILED [ 28%]
tests/test_news.py::TestNewsAPI::test_news_update_authenticated FAILED   [ 28%]
tests/test_news.py::TestNewsAPI::test_news_delete_authenticated FAILED   [ 29%]
tests/test_news.py::TestNewsAPI::test_news_filter_by_category FAILED     [ 30%]
tests/test_news.py::TestNewsAPI::test_news_search FAILED                 [ 31%]
tests/test_news.py::TestNewsAPI::test_news_urgent_filter FAILED          [ 31%]
tests/test_news.py::TestCategoryAPI::test_category_list PASSED           [ 32%]
tests/test_news.py::TestCategoryAPI::test_category_detail PASSED         [ 33%]
tests/test_news.py::TestCategoryAPI::test_category_create_admin ERROR    [ 34%]
tests/test_news.py::TestCategoryAPI::test_category_create_user FAILED    [ 34%]
tests/test_news.py::TestTagAPI::test_tag_list FAILED                     [ 35%]
tests/test_news.py::TestTagAPI::test_tag_autocomplete FAILED             [ 36%]
tests/test_news.py::TestTagAPI::test_tag_usage_count PASSED              [ 36%]
tests/test_webhooks.py::TestWebhookSourceModel::test_webhook_source_creation PASSED [ 37%]
tests/test_webhooks.py::TestWebhookSourceModel::test_webhook_source_stats PASSED [ 38%]
tests/test_webhooks.py::TestWebhookLogModel::test_webhook_log_creation PASSED [ 39%]
tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_list_admin ERROR [ 39%]
tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_list_user FAILED [ 40%]
tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_create_admin ERROR [ 41%]
tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_update_admin ERROR [ 42%]
tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_delete_admin ERROR [ 42%]
tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_inactive_source PASSED [ 43%]
tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_nonexistent_source PASSED [ 44%]
tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_async_processing FAILED [ 44%]
tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_creates_log PASSED [ 45%]
tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_rate_limiting PASSED [ 46%]
tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_json_validation PASSED [ 47%]
tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_list_admin ERROR [ 47%]
tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_list_user FAILED [ 48%]
tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_filter_by_source ERROR [ 49%]
tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_filter_by_status ERROR [ 50%]
tests/integration/test_news_api.py::TestNewsAPI::test_list_news_authenticated PASSED [ 50%]
tests/integration/test_news_api.py::TestNewsAPI::test_list_news_unauthenticated FAILED [ 51%]
tests/integration/test_news_api.py::TestNewsAPI::test_retrieve_news PASSED [ 52%]
tests/integration/test_news_api.py::TestNewsAPI::test_create_news FAILED [ 52%]
tests/integration/test_news_api.py::TestNewsAPI::test_update_news PASSED [ 53%]
tests/integration/test_news_api.py::TestNewsAPI::test_filter_news_by_category ERROR [ 54%]
tests/integration/test_news_api.py::TestNewsAPI::test_search_news ERROR  [ 55%]
tests/integration/test_news_api.py::TestNewsAPI::test_mark_news_urgent PASSED [ 55%]
tests/integration/test_news_api.py::TestNewsAPI::test_share_news PASSED  [ 56%]
tests/integration/test_news_api.py::TestNewsAPI::test_get_related_news ERROR [ 57%]
tests/integration/test_news_api.py::TestNewsAPI::test_advanced_search ERROR [ 57%]
tests/integration/test_news_api.py::TestCategoryAPI::test_list_categories FAILED [ 58%]
tests/integration/test_news_api.py::TestCategoryAPI::test_create_category PASSED [ 59%]
tests/integration/test_news_api.py::TestCategoryAPI::test_category_statistics PASSED [ 60%]
tests/integration/test_news_api.py::TestTagAPI::test_list_tags PASSED    [ 60%]
tests/integration/test_news_api.py::TestTagAPI::test_create_tag PASSED   [ 61%]
tests/integration/test_news_api.py::TestNewsPermissions::test_unauthenticated_access_denied FAILED [ 62%]
tests/integration/test_news_api.py::TestNewsPermissions::test_read_only_access_for_regular_users PASSED [ 63%]
tests/integration/test_webhook_integration.py::TestWebhookEndpoints::test_webhook_source_crud PASSED [ 63%]
tests/integration/test_webhook_integration.py::TestWebhookEndpoints::test_webhook_statistics PASSED [ 64%]
tests/integration/test_webhook_integration.py::TestWebhookEndpoints::test_webhook_test_endpoint PASSED [ 65%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_valid_webhook FAILED [ 65%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_json FAILED [ 66%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_missing_required_fields FAILED [ 67%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_webhook_signature_verification FAILED [ 68%]
tests/integration/test_webhook_integration.py::TestWebhookDashboard::test_webhook_dashboard FAILED [ 68%]
tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_processing_task_triggered FAILED [ 69%]
tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_log_creation FAILED [ 70%]
tests/unit/test_classification_models.py::TestClassificationRule::test_create_classification_rule PASSED [ 71%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_increment_matches PASSED [ 71%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_increment_successful_classifications PASSED [ 72%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_success_rate_calculation PASSED [ 73%]
tests/unit/test_classification_models.py::TestClassificationRule::test_rule_unique_name PASSED [ 73%]
tests/unit/test_classification_models.py::TestClassificationModel::test_create_classification_model PASSED [ 74%]
tests/unit/test_classification_models.py::TestClassificationModel::test_model_increment_predictions PASSED [ 75%]
tests/unit/test_classification_models.py::TestClassificationResult::test_create_classification_result PASSED [ 76%]
tests/unit/test_classification_models.py::TestClassificationResult::test_accept_classification PASSED [ 76%]
tests/unit/test_classification_models.py::TestClassificationTrainingData::test_create_training_data PASSED [ 77%]
tests/unit/test_classification_models.py::TestClassificationStatistic::test_create_classification_statistic PASSED [ 78%]
tests/unit/test_classification_models.py::TestClassificationStatistic::test_statistic_success_rate_calculation PASSED [ 78%]
tests/unit/test_news_models.py::TestCategoryModel::test_create_category PASSED [ 79%]
tests/unit/test_news_models.py::TestCategoryModel::test_category_unique_name PASSED [ 80%]
tests/unit/test_news_models.py::TestCategoryModel::test_category_unique_slug PASSED [ 81%]
tests/unit/test_news_models.py::TestSubcategoryModel::test_create_subcategory PASSED [ 81%]
tests/unit/test_news_models.py::TestSubcategoryModel::test_subcategory_category_slug_unique_together PASSED [ 82%]
tests/unit/test_news_models.py::TestTagModel::test_create_tag PASSED     [ 83%]
tests/unit/test_news_models.py::TestTagModel::test_tag_unique_name PASSED [ 84%]
tests/unit/test_news_models.py::TestNewsModel::test_create_news PASSED   [ 84%]
tests/unit/test_news_models.py::TestNewsModel::test_news_auto_word_count PASSED [ 85%]
tests/unit/test_news_models.py::TestNewsModel::test_news_auto_reading_time PASSED [ 86%]
tests/unit/test_news_models.py::TestNewsModel::test_news_auto_summary_generation PASSED [ 86%]
tests/unit/test_news_models.py::TestNewsModel::test_news_increment_view_count PASSED [ 87%]
tests/unit/test_news_models.py::TestNewsModel::test_news_increment_share_count PASSED [ 88%]
tests/unit/test_news_models.py::TestNewsModel::test_news_external_id_unique PASSED [ 89%]
tests/unit/test_news_models.py::TestNewsProcessingLog::test_create_processing_log PASSED [ 89%]
tests/unit/test_news_serializers.py::TestCategorySerializer::test_serialize_category PASSED [ 90%]
tests/unit/test_news_serializers.py::TestCategorySerializer::test_deserialize_category PASSED [ 91%]
tests/unit/test_news_serializers.py::TestSubcategorySerializer::test_serialize_subcategory FAILED [ 92%]
tests/unit/test_news_serializers.py::TestTagSerializer::test_serialize_tag PASSED [ 92%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_list_serializer PASSED [ 93%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_detail_serializer PASSED [ 94%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_create_serializer PASSED [ 94%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_update_serializer PASSED [ 95%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_create_serializer_validation PASSED [ 96%]
tests/unit/test_news_serializers.py::TestNewsSerializers::test_news_create_with_duplicate_external_id PASSED [ 97%]
tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_source FAILED [ 97%]
tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_verification FAILED [ 98%]
tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_verification_invalid_token PASSED [ 99%]
tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_message_receive FAILED [100%]

==================================== ERRORS ====================================
_________ ERROR at setup of TestCategoryAPI.test_category_create_admin _________

self = <django.db.backends.utils.CursorWrapper object at 0x753272d3d750>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$xIOFi3v4xcTTitEMmavNcO$eFvPaKZdSGd6rtDfAf7qztqZnJkLK2nAvd1Z0m4WcIk=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272d3d750>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x753272d3d750>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$xIOFi3v4xcTTitEMmavNcO$eFvPaKZdSGd6rtDfAf7qztqZnJkLK2nAvd1Z0m4WcIk=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272d3d750>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_______ ERROR at setup of TestWebhookAPI.test_webhook_source_list_admin ________

self = <django.db.backends.utils.CursorWrapper object at 0x753272852a90>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$l5hoTGWI509yKAoZpZ3WJu$wy7oX+mjEjO83marhvasLsNlBvKtX8Z/G6g2kfbao6U=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272852a90>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x753272852a90>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$l5hoTGWI509yKAoZpZ3WJu$wy7oX+mjEjO83marhvasLsNlBvKtX8Z/G6g2kfbao6U=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272852a90>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
______ ERROR at setup of TestWebhookAPI.test_webhook_source_create_admin _______

self = <django.db.backends.utils.CursorWrapper object at 0x753272d21d50>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$2D0MgAKdpGR2pAIfPvLch2$EpMGOTNzGmfgxucxM3en44MpvtAoeTaNJnBsXivtKU8=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272d21d50>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x753272d21d50>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$2D0MgAKdpGR2pAIfPvLch2$EpMGOTNzGmfgxucxM3en44MpvtAoeTaNJnBsXivtKU8=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272d21d50>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
______ ERROR at setup of TestWebhookAPI.test_webhook_source_update_admin _______

self = <django.db.backends.utils.CursorWrapper object at 0x753272f862d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$Wv8cZKiptmEzJ4dvDduJze$Q8MjLbbNIXu7ghge9kbtH1+FVTSmHirxKezvxeYX8LI=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272f862d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x753272f862d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$Wv8cZKiptmEzJ4dvDduJze$Q8MjLbbNIXu7ghge9kbtH1+FVTSmHirxKezvxeYX8LI=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272f862d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
______ ERROR at setup of TestWebhookAPI.test_webhook_source_delete_admin _______

self = <django.db.backends.utils.CursorWrapper object at 0x7532732b9750>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$J8qSXDeSZYDrKm9CCFT5m4$bS+trNhMIxUTCjvSmOEcjTgQ+Onpjv0R3XFVXWLXpHc=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532732b9750>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532732b9750>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$J8qSXDeSZYDrKm9CCFT5m4$bS+trNhMIxUTCjvSmOEcjTgQ+Onpjv0R3XFVXWLXpHc=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532732b9750>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_______ ERROR at setup of TestWebhookLogAPI.test_webhook_log_list_admin ________

self = <django.db.backends.utils.CursorWrapper object at 0x753272d753d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$IskajziLgglo0tkL08j1y5$3Qng4ouDQiLK8tWEtpVAAGVVRqgKbEWWngOYWqEAMcw=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272d753d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x753272d753d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$IskajziLgglo0tkL08j1y5$3Qng4ouDQiLK8tWEtpVAAGVVRqgKbEWWngOYWqEAMcw=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272d753d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
____ ERROR at setup of TestWebhookLogAPI.test_webhook_log_filter_by_source _____

self = <django.db.backends.utils.CursorWrapper object at 0x7532732b9a50>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$IqF2hN913dZiXyxXFLRG7M$8tqJoTBxUYeW3m7dAvyaWha7SG/4Qxht02vClLOeIyk=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532732b9a50>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532732b9a50>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$IqF2hN913dZiXyxXFLRG7M$8tqJoTBxUYeW3m7dAvyaWha7SG/4Qxht02vClLOeIyk=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532732b9a50>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
____ ERROR at setup of TestWebhookLogAPI.test_webhook_log_filter_by_status _____

self = <django.db.backends.utils.CursorWrapper object at 0x7532726f24d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$xgltleTIwzETpojZILh1f2$CRPidDGVEg3IJrh8NnZRx5ILNLMVlPSI26RBXPycDfA=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532726f24d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None

    @pytest.fixture
    def admin_user(db):
        """Create an admin user."""
        User = get_user_model()
>       return User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/conftest.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532726f24d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$xgltleTIwzETpojZILh1f2$CRPidDGVEg3IJrh8NnZRx5ILNLMVlPSI26RBXPycDfA=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532726f24d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
__________ ERROR at setup of TestNewsAPI.test_filter_news_by_category __________

self = <django.db.backends.utils.CursorWrapper object at 0x7532726cd210>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('e427bfc7-2f19-4a51-9980-9edd86b68c5b'), datetime.datetime(2025, 7, 9, 21, 34, 39, 905361, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532726cd210>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532726cd210>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('e427bfc7-2f19-4a51-9980-9edd86b68c5b'), datetime.datetime(2025, 7, 9, 21, 34, 39, 905361, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532726cd210>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
________________ ERROR at setup of TestNewsAPI.test_search_news ________________

self = <django.db.backends.utils.CursorWrapper object at 0x75327363c550>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('13f04b5d-8a32-4a52-a04a-b7434a44059a'), datetime.datetime(2025, 7, 9, 21, 34, 40, 619837, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x75327363c550>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x75327363c550>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('13f04b5d-8a32-4a52-a04a-b7434a44059a'), datetime.datetime(2025, 7, 9, 21, 34, 40, 619837, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x75327363c550>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_____________ ERROR at setup of TestNewsAPI.test_get_related_news ______________

self = <django.db.backends.utils.CursorWrapper object at 0x7532b8bf3a10>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('2a8badf4-42a3-4fd1-bde4-815a31a0b89d'), datetime.datetime(2025, 7, 9, 21, 34, 41, 930691, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532b8bf3a10>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532b8bf3a10>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('2a8badf4-42a3-4fd1-bde4-815a31a0b89d'), datetime.datetime(2025, 7, 9, 21, 34, 41, 930691, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532b8bf3a10>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
______________ ERROR at setup of TestNewsAPI.test_advanced_search ______________

self = <django.db.backends.utils.CursorWrapper object at 0x753272953250>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('86690314-38dc-469e-adb6-cd6db73f0e93'), datetime.datetime(2025, 7, 9, 21, 34, 42, 563405, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272953250>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

db = None, category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    @pytest.fixture
    def multiple_news(db, category, subcategory):
        """Create multiple news articles for bulk testing."""
        news_items = []
    
        for i in range(5):
>           news_item = News.objects.create(
                title=f'Test News Article {i+1}',
                content=f'This is test news article number {i+1} with unique content.',
                source=f'Test Source {i+1}',
                author=f'Test Author {i+1}',
                category=category,
                subcategory=subcategory if i % 2 == 0 else None,
                published_at=timezone.now() - timedelta(days=i),
                is_published=True,
                is_urgent=i == 0  # First one is urgent
            )

tests/conftest.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:658: in create
    obj.save(force_insert=True, using=self.db)
apps/news/models.py:173: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x753272953250>
sql = 'INSERT INTO "news_news" ("id", "created_at", "updated_at", "title", "content", "summary", "source", "source_url", "au...t", "share_count") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = (UUID('86690314-38dc-469e-adb6-cd6db73f0e93'), datetime.datetime(2025, 7, 9, 21, 34, 42, 563405, tzinfo=datetime.timez...is is test news article number 2 with unique content.', 'This is test news article number 2 with unique content.', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x753272953250>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "news_news_external_id_key"
E               DETAIL:  Key (external_id)=() already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
=================================== FAILURES ===================================
____________________ TestUserModel.test_superuser_creation _____________________

self = <django.db.backends.utils.CursorWrapper object at 0x7532b8766010>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$5h1qI7opC8VOZTinPc3dEU$VuBseG2xl5HwxffhCMOi51NFhVIsO28M8IoHc/X6ZO4=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532b8766010>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.test_authentication.TestUserModel object at 0x7532b8731210>

    def test_superuser_creation(self):
        """Test superuser can be created."""
>       admin = User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/test_authentication.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532b8766010>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$5h1qI7opC8VOZTinPc3dEU$VuBseG2xl5HwxffhCMOi51NFhVIsO28M8IoHc/X6ZO4=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532b8766010>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_______________________ TestAPIKeyModel.test_api_key_str _______________________

self = <tests.test_authentication.TestAPIKeyModel object at 0x7532b8731ed0>
user = <User: test@example.com>

    def test_api_key_str(self, user):
        """Test API key string representation."""
        api_key = APIKey.objects.create(
            user=user,
            name='Test API Key',
            key='test-key-123'
        )
>       assert str(api_key) == 'Test API Key (test@example.com)'
E       AssertionError: assert 'Test API Key...t@example.com' == 'Test API Key...@example.com)'
E         - Test API Key (test@example.com)
E         ?              ^                -
E         + Test API Key - test@example.com
E         ?              ^^

tests/test_authentication.py:81: AssertionError
_________________ TestAuthenticationAPI.test_user_registration _________________

self = <tests.test_authentication.TestAuthenticationAPI object at 0x7532b8733dd0>
api_client = <rest_framework.test.APIClient object at 0x753273638990>

    def test_user_registration(self, api_client):
        """Test user registration."""
        url = reverse('auth:user_register')
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'newpass123',
            'first_name': 'New',
            'last_name': 'User'
        }
        response = api_client.post(url, data)
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response status_code=400, "application/json">.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests/test_authentication.py:139: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/auth/register/
INFO Request completed - POST /api/v1/auth/register/ - 400
WARNING Bad Request: /api/v1/auth/register/
_________________ TestAuthenticationAPI.test_user_profile_get __________________

self = <tests.test_authentication.TestAuthenticationAPI object at 0x7532b8719650>
authenticated_client = <rest_framework.test.APIClient object at 0x753273583750>
user = <User: test@example.com>

    def test_user_profile_get(self, authenticated_client, user):
        """Test getting user profile."""
        url = reverse('auth:user_profile')
        response = authenticated_client.get(url)
        assert response.status_code == status.HTTP_200_OK
>       assert response.data['email'] == user.email
E       KeyError: 'email'

tests/test_authentication.py:148: KeyError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/auth/profile/
INFO Request completed - GET /api/v1/auth/profile/ - 200
_____________ TestAPIKeyAuthentication.test_api_key_authentication _____________

self = <tests.test_authentication.TestAPIKeyAuthentication object at 0x7532b871b750>
api_client = <rest_framework.test.APIClient object at 0x7532733d05d0>
user = <User: test@example.com>
api_key = <APIKey: Test API Key - test@example.com>

    def test_api_key_authentication(self, api_client, user, api_key):
        """Test API key authentication works."""
        api_client.credentials(HTTP_AUTHORIZATION=f'Api-Key {api_key.key}')
        url = reverse('auth:user_profile')
        response = api_client.get(url)
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <Response status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/test_authentication.py:178: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/auth/profile/
INFO Request completed - GET /api/v1/auth/profile/ - 401
WARNING Unauthorized: /api/v1/auth/profile/
____________________ TestUserModel.test_superuser_creation _____________________

self = <django.db.backends.utils.CursorWrapper object at 0x7532734024d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$400McWsUD6kAwBMwIS9scL$wbC22Gx+tWodx80brRMCby7KTOAwKttgivgG3tenODU=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532734024d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               psycopg2.errors.UniqueViolation: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: UniqueViolation

The above exception was the direct cause of the following exception:

self = <tests.test_authentication_fixed.TestUserModel object at 0x7532b8b6dbd0>

    def test_superuser_creation(self):
        """Test superuser can be created."""
>       admin = User.objects.create_superuser(
            username='admin',
            email='admin@example.com',
            password='adminpass123'
        )

tests/test_authentication_fixed.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:172: in create_superuser
    return self._create_user(username, email, password, **extra_fields)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/models.py:155: in _create_user
    user.save(using=self._db)
/usr/local/lib/python3.11/site-packages/django/contrib/auth/base_user.py:76: in save
    super().save(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:814: in save
    self.save_base(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:877: in save_base
    updated = self._save_table(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1020: in _save_table
    results = self._do_insert(
/usr/local/lib/python3.11/site-packages/django/db/models/base.py:1061: in _do_insert
    return manager._insert(
/usr/local/lib/python3.11/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/db/models/query.py:1805: in _insert
    return query.get_compiler(using=using).execute_sql(returning_fields)
/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py:1822: in execute_sql
    cursor.execute(sql, params)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:67: in execute
    return self._execute_with_wrappers(
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:80: in _execute_with_wrappers
    return executor(sql, params, many, context)
/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:84: in _execute
    with self.db.wrap_database_errors:
/usr/local/lib/python3.11/site-packages/django/db/utils.py:91: in __exit__
    raise dj_exc_value.with_traceback(traceback) from exc_value
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.db.backends.utils.CursorWrapper object at 0x7532734024d0>
sql = 'INSERT INTO "auth_user" ("password", "last_login", "is_superuser", "username", "first_name", "last_name", "is_staff",...language", "created_at", "updated_at") VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)'
params = ('pbkdf2_sha256$600000$400McWsUD6kAwBMwIS9scL$wbC22Gx+tWodx80brRMCby7KTOAwKttgivgG3tenODU=', None, True, 'admin', '', '', ...)
ignored_wrapper_args = (False, {'connection': <DatabaseWrapper vendor='postgresql' alias='default'>, 'cursor': <django.db.backends.utils.CursorWrapper object at 0x7532734024d0>})

    def _execute(self, sql, params, *ignored_wrapper_args):
        self.db.validate_no_broken_transaction()
        with self.db.wrap_database_errors:
            if params is None:
                # params default might be backend specific.
                return self.cursor.execute(sql)
            else:
>               return self.cursor.execute(sql, params)
E               django.db.utils.IntegrityError: duplicate key value violates unique constraint "auth_user_username_key"
E               DETAIL:  Key (username)=(admin) already exists.

/usr/local/lib/python3.11/site-packages/django/db/backends/utils.py:89: IntegrityError
_______________________ TestAPIKeyModel.test_api_key_str _______________________

self = <tests.test_authentication_fixed.TestAPIKeyModel object at 0x7532b8b6f790>
user = <User: test@example.com>

    def test_api_key_str(self, user):
        """Test API key string representation."""
        api_key = APIKey.objects.create(
            user=user,
            name='Test API Key',
            key='test-key-123'
        )
>       assert str(api_key) == 'Test API Key (test@example.com)'
E       AssertionError: assert 'Test API Key...t@example.com' == 'Test API Key...@example.com)'
E         - Test API Key (test@example.com)
E         ?              ^                -
E         + Test API Key - test@example.com
E         ?              ^^

tests/test_authentication_fixed.py:81: AssertionError
_________________ TestAuthenticationAPI.test_user_registration _________________

self = <tests.test_authentication_fixed.TestAuthenticationAPI object at 0x7532b8b3f250>
api_client = <rest_framework.test.APIClient object at 0x753273597ed0>

    def test_user_registration(self, api_client):
        """Test user registration."""
        url = reverse('auth:user_register')
        data = {
            'username': 'newuser',
            'email': 'newuser@example.com',
            'password': 'newpass123',
            'first_name': 'New',
            'last_name': 'User'
        }
        response = api_client.post(url, data)
>       assert response.status_code == status.HTTP_201_CREATED
E       assert 400 == 201
E        +  where 400 = <Response status_code=400, "application/json">.status_code
E        +  and   201 = status.HTTP_201_CREATED

tests/test_authentication_fixed.py:139: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/auth/register/
INFO Request completed - POST /api/v1/auth/register/ - 400
WARNING Bad Request: /api/v1/auth/register/
_________________ TestAuthenticationAPI.test_user_profile_get __________________

self = <tests.test_authentication_fixed.TestAuthenticationAPI object at 0x7532b8b3f750>
authenticated_client = <rest_framework.test.APIClient object at 0x7532732e5150>
user = <User: test@example.com>

    def test_user_profile_get(self, authenticated_client, user):
        """Test getting user profile."""
        url = reverse('auth:user_profile')
        response = authenticated_client.get(url)
        assert response.status_code == status.HTTP_200_OK
>       assert response.data['email'] == user.email
E       KeyError: 'email'

tests/test_authentication_fixed.py:148: KeyError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/auth/profile/
INFO Request completed - GET /api/v1/auth/profile/ - 200
_____________ TestAPIKeyAuthentication.test_api_key_authentication _____________

self = <tests.test_authentication_fixed.TestAPIKeyAuthentication object at 0x7532b8b537d0>
api_client = <rest_framework.test.APIClient object at 0x753273582710>
user = <User: test@example.com>
api_key = <APIKey: Test API Key - test@example.com>

    def test_api_key_authentication(self, api_client, user, api_key):
        """Test API key authentication works."""
        api_client.credentials(HTTP_AUTHORIZATION=f'Api-Key {api_key.key}')
        url = reverse('auth:user_profile')
        response = api_client.get(url)
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <Response status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/test_authentication_fixed.py:178: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/auth/profile/
INFO Request completed - GET /api/v1/auth/profile/ - 401
WARNING Unauthorized: /api/v1/auth/profile/
______________________ TestNewsAPI.test_news_list_public _______________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87e6a50>
api_client = <rest_framework.test.APIClient object at 0x753272a88ed0>
news_article = <News: Test News Article>

    def test_news_list_public(self, api_client, news_article):
        """Test public news list endpoint."""
>       url = reverse('news:article-list')

tests/test_news.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-list' not found. 'article-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
_____________________ TestNewsAPI.test_news_detail_public ______________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87e7310>
api_client = <rest_framework.test.APIClient object at 0x7532733a4090>
news_article = <News: Test News Article>

    def test_news_detail_public(self, api_client, news_article):
        """Test public news detail endpoint."""
>       url = reverse('news:article-detail', kwargs={'pk': news_article.id})

tests/test_news.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-detail', _prefix = '/', args = ()
kwargs = {'pk': UUID('7482176d-cc45-430b-8063-275d88e5e94a')}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-detail' not found. 'article-detail' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
__________________ TestNewsAPI.test_news_create_authenticated __________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87e7650>
authenticated_client = <rest_framework.test.APIClient object at 0x7532733a5090>
category = <Category: Test Category>
sample_news_data = {'author': 'Economic Reporter', 'content': 'The government has announced a new economic policy that will impact various sectors...', 'is_urgent': True, 'source': 'Economic Times', ...}

    def test_news_create_authenticated(self, authenticated_client, category, sample_news_data):
        """Test news creation with authentication."""
>       url = reverse('news:article-list')

tests/test_news.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-list' not found. 'article-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
_________________ TestNewsAPI.test_news_create_unauthenticated _________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87d8150>
api_client = <rest_framework.test.APIClient object at 0x75327333b690>
sample_news_data = {'author': 'Economic Reporter', 'content': 'The government has announced a new economic policy that will impact various sectors...', 'is_urgent': True, 'source': 'Economic Times', ...}

    def test_news_create_unauthenticated(self, api_client, sample_news_data):
        """Test news creation without authentication."""
>       url = reverse('news:article-list')

tests/test_news.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-list' not found. 'article-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
__________________ TestNewsAPI.test_news_update_authenticated __________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87d8450>
authenticated_client = <rest_framework.test.APIClient object at 0x753272d19010>
news_article = <News: Test News Article>

    def test_news_update_authenticated(self, authenticated_client, news_article):
        """Test news update with authentication."""
>       url = reverse('news:article-detail', kwargs={'pk': news_article.id})

tests/test_news.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-detail', _prefix = '/', args = ()
kwargs = {'pk': UUID('52abd2f5-de7b-4b46-bfcf-d5ff888fc142')}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-detail' not found. 'article-detail' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
__________________ TestNewsAPI.test_news_delete_authenticated __________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87d9210>
authenticated_client = <rest_framework.test.APIClient object at 0x753272d22050>
news_article = <News: Test News Article>

    def test_news_delete_authenticated(self, authenticated_client, news_article):
        """Test news deletion with authentication."""
>       url = reverse('news:article-detail', kwargs={'pk': news_article.id})

tests/test_news.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-detail', _prefix = '/', args = ()
kwargs = {'pk': UUID('b74bb741-8c38-4f0f-b6f7-d044d7902ef1')}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-detail' not found. 'article-detail' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
___________________ TestNewsAPI.test_news_filter_by_category ___________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87d9dd0>
api_client = <rest_framework.test.APIClient object at 0x7532736139d0>
news_article = <News: Test News Article>, category = <Category: Test Category>

    def test_news_filter_by_category(self, api_client, news_article, category):
        """Test news filtering by category."""
>       url = reverse('news:article-list')

tests/test_news.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-list' not found. 'article-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
_________________________ TestNewsAPI.test_news_search _________________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87db710>
api_client = <rest_framework.test.APIClient object at 0x75327336fd90>
news_article = <News: Test News Article>

    def test_news_search(self, api_client, news_article):
        """Test news search functionality."""
>       url = reverse('news:article-list')

tests/test_news.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-list' not found. 'article-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
_____________________ TestNewsAPI.test_news_urgent_filter ______________________

self = <tests.test_news.TestNewsAPI object at 0x7532b87d9290>
api_client = <rest_framework.test.APIClient object at 0x753272d22dd0>
category = <Category: Test Category>

    def test_news_urgent_filter(self, api_client, category):
        """Test urgent news filtering."""
        # Create urgent news
        urgent_news = News.objects.create(
            title='Urgent News',
            content='This is urgent',
            category=category,
            is_urgent=True,
            published_at=timezone.now()
        )
    
>       url = reverse('news:article-list')

tests/test_news.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'article-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'article-list' not found. 'article-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
__________________ TestCategoryAPI.test_category_create_user ___________________

self = <tests.test_news.TestCategoryAPI object at 0x7532b87db110>
authenticated_client = <rest_framework.test.APIClient object at 0x7532728513d0>

    def test_category_create_user(self, authenticated_client):
        """Test category creation by regular user (should fail)."""
        url = reverse('news:category-list')
        data = {
            'name': 'New Category',
            'slug': 'new-category',
            'description': 'New description'
        }
        response = authenticated_client.post(url, data)
>       assert response.status_code == status.HTTP_403_FORBIDDEN
E       assert 201 == 403
E        +  where 201 = <Response status_code=201, "application/json">.status_code
E        +  and   403 = status.HTTP_403_FORBIDDEN

tests/test_news.py:212: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/news/categories/
INFO Request completed - POST /api/v1/news/categories/ - 201
___________________________ TestTagAPI.test_tag_list ___________________________

self = <tests.test_news.TestTagAPI object at 0x7532b87dbe10>
api_client = <rest_framework.test.APIClient object at 0x7532b87e6390>
tag = <Tag: Test Tag>

    def test_tag_list(self, api_client, tag):
        """Test tag list endpoint."""
        url = reverse('news:tag-list')
        response = api_client.get(url)
>       assert response.status_code == status.HTTP_200_OK
E       assert 429 == 200
E        +  where 429 = <Response status_code=429, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/test_news.py:223: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/tags/
INFO Request completed - GET /api/v1/news/tags/ - 429
WARNING Too Many Requests: /api/v1/news/tags/
_______________________ TestTagAPI.test_tag_autocomplete _______________________

self = <tests.test_news.TestTagAPI object at 0x7532b87c7490>
api_client = <rest_framework.test.APIClient object at 0x7532729cfed0>
tag = <Tag: Test Tag>

    def test_tag_autocomplete(self, api_client, tag):
        """Test tag autocomplete functionality."""
        url = reverse('news:tag-list')
        response = api_client.get(url, {'search': 'Break'})
>       assert response.status_code == status.HTTP_200_OK
E       assert 429 == 200
E        +  where 429 = <Response status_code=429, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/test_news.py:231: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/tags/
INFO Request completed - GET /api/v1/news/tags/ - 429
WARNING Too Many Requests: /api/v1/news/tags/
_________________ TestWebhookAPI.test_webhook_source_list_user _________________

self = <tests.test_webhooks.TestWebhookAPI object at 0x7532b8716510>
authenticated_client = <rest_framework.test.APIClient object at 0x75327299ce90>
webhook_source = <WebhookSource: Test Webhook Source>

    def test_webhook_source_list_user(self, authenticated_client, webhook_source):
        """Test webhook source list for regular user (should fail)."""
>       url = reverse('webhooks:source-list')

tests/test_webhooks.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'source-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'source-list' not found. 'source-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
__________ TestWebhookReceiver.test_webhook_receive_async_processing ___________

args = (<tests.test_webhooks.TestWebhookReceiver object at 0x7532b8bf2910>,)
keywargs = {'api_client': <rest_framework.test.APIClient object at 0x75327302c810>, 'sample_webhook_data': {'author': 'Webhook Au...', 'external_id': 'd0564a59-e5c0-4b3a-bdc5-95099f7322df', ...}, 'webhook_source': <WebhookSource: Test Webhook Source>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/local/lib/python3.11/unittest/mock.py:1375: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/local/lib/python3.11/unittest/mock.py:1357: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/local/lib/python3.11/contextlib.py:517: in enter_context
    result = _enter(cm)
/usr/local/lib/python3.11/unittest/mock.py:1430: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'apps.webhooks.tasks.process_webhook_data'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P<pkg>{dotted_words})'
                                       f'(?P<cln>:(?P<obj>{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
>           result = getattr(result, p)
E           AttributeError: module 'apps.webhooks.tasks' has no attribute 'process_webhook_data'

/usr/local/lib/python3.11/pkgutil.py:715: AttributeError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
_________________ TestWebhookLogAPI.test_webhook_log_list_user _________________

self = <tests.test_webhooks.TestWebhookLogAPI object at 0x7532b87308d0>
authenticated_client = <rest_framework.test.APIClient object at 0x753273119310>
webhook_source = <WebhookSource: Test Webhook Source>

    def test_webhook_log_list_user(self, authenticated_client, webhook_source):
        """Test webhook log list for regular user (should fail)."""
>       url = reverse('webhooks:log-list')

tests/test_webhooks.py:323: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/django/urls/base.py:88: in reverse
    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver <URLResolver list> (None:None) '^/'>
lookup_view = 'log-list', _prefix = '/', args = (), kwargs = {}
possibilities = []

    def _reverse_with_prefix(self, lookup_view, _prefix, *args, **kwargs):
        if args and kwargs:
            raise ValueError("Don't mix *args and **kwargs in call to reverse()!")
    
        if not self._populated:
            self._populate()
    
        possibilities = self.reverse_dict.getlist(lookup_view)
    
        for possibility, pattern, defaults, converters in possibilities:
            for result, params in possibility:
                if args:
                    if len(args) != len(params):
                        continue
                    candidate_subs = dict(zip(params, args))
                else:
                    if set(kwargs).symmetric_difference(params).difference(defaults):
                        continue
                    matches = True
                    for k, v in defaults.items():
                        if k in params:
                            continue
                        if kwargs.get(k, v) != v:
                            matches = False
                            break
                    if not matches:
                        continue
                    candidate_subs = kwargs
                # Convert the candidate subs to text using Converter.to_url().
                text_candidate_subs = {}
                match = True
                for k, v in candidate_subs.items():
                    if k in converters:
                        try:
                            text_candidate_subs[k] = converters[k].to_url(v)
                        except ValueError:
                            match = False
                            break
                    else:
                        text_candidate_subs[k] = str(v)
                if not match:
                    continue
                # WSGI provides decoded URLs, without %xx escapes, and the URL
                # resolver operates on such URLs. First substitute arguments
                # without quoting to build a decoded URL and look for a match.
                # Then, if we have a match, redo the substitution with quoted
                # arguments in order to return a properly encoded URL.
                candidate_pat = _prefix.replace("%", "%%") + result
                if re.search(
                    "^%s%s" % (re.escape(_prefix), pattern),
                    candidate_pat % text_candidate_subs,
                ):
                    # safe characters from `pchar` definition of RFC 3986
                    url = quote(
                        candidate_pat % text_candidate_subs,
                        safe=RFC3986_SUBDELIMS + "/~:@",
                    )
                    # Don't allow construction of scheme relative urls.
                    return escape_leading_slashes(url)
        # lookup_view can be URL name or callable, but callables are not
        # friendly in error messages.
        m = getattr(lookup_view, "__module__", None)
        n = getattr(lookup_view, "__name__", None)
        if m is not None and n is not None:
            lookup_view_s = "%s.%s" % (m, n)
        else:
            lookup_view_s = lookup_view
    
        patterns = [pattern for (_, pattern, _, _) in possibilities]
        if patterns:
            if args:
                arg_msg = "arguments '%s'" % (args,)
            elif kwargs:
                arg_msg = "keyword arguments '%s'" % kwargs
            else:
                arg_msg = "no arguments"
            msg = "Reverse for '%s' with %s not found. %d pattern(s) tried: %s" % (
                lookup_view_s,
                arg_msg,
                len(patterns),
                patterns,
            )
        else:
            msg = (
                "Reverse for '%(view)s' not found. '%(view)s' is not "
                "a valid view function or pattern name." % {"view": lookup_view_s}
            )
>       raise NoReverseMatch(msg)
E       django.urls.exceptions.NoReverseMatch: Reverse for 'log-list' not found. 'log-list' is not a valid view function or pattern name.

/usr/local/lib/python3.11/site-packages/django/urls/resolvers.py:828: NoReverseMatch
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
__________________ TestNewsAPI.test_list_news_unauthenticated __________________

self = <tests.integration.test_news_api.TestNewsAPI object at 0x7532b839d710>
api_client = <rest_framework.test.APIClient object at 0x7532730ac210>
news = <News: Test News Article>

    def test_list_news_unauthenticated(self, api_client, news):
        """Test listing news without authentication."""
        url = reverse('news:news-list')
        response = api_client.get(url)
    
>       assert response.status_code == status.HTTP_401_UNAUTHORIZED
E       assert 429 == 401
E        +  where 429 = <Response status_code=429, "application/json">.status_code
E        +  and   401 = status.HTTP_401_UNAUTHORIZED

tests/integration/test_news_api.py:32: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/articles/
INFO Request completed - GET /api/v1/news/articles/ - 429
WARNING Too Many Requests: /api/v1/news/articles/
_________________________ TestNewsAPI.test_create_news _________________________

self = <tests.integration.test_news_api.TestNewsAPI object at 0x7532b839da50>
authenticated_client = <rest_framework.test.APIClient object at 0x753272d64d10>
category = <Category: Test Category>
subcategory = <Subcategory: Test Category - Test Subcategory>

    def test_create_news(self, authenticated_client, category, subcategory):
        """Test creating news via API."""
        url = reverse('news:news-list')
        data = {
            'title': 'API Created News',
            'content': 'This news was created via API with sufficient content length.',
            'source': 'API Test',
            'author': 'Test Author',
            'category': str(category.id),
            'subcategory': str(subcategory.id),
            'tag_names': ['api', 'test'],
            'is_published': True
        }
    
        response = authenticated_client.post(url, data)
    
        assert response.status_code == status.HTTP_201_CREATED
        assert response.data['title'] == 'API Created News'
>       assert response.data['category'] == str(category.id)
E       AssertionError: assert UUID('446fdcbe-ab9f-442f-b3e1-a2a99a00e28b') == '446fdcbe-ab9f-442f-b3e1-a2a99a00e28b'
E        +  where '446fdcbe-ab9f-442f-b3e1-a2a99a00e28b' = str(UUID('446fdcbe-ab9f-442f-b3e1-a2a99a00e28b'))
E        +    where UUID('446fdcbe-ab9f-442f-b3e1-a2a99a00e28b') = <Category: Test Category>.id

tests/integration/test_news_api.py:63: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/news/articles/
INFO Request completed - POST /api/v1/news/articles/ - 201
_____________________ TestCategoryAPI.test_list_categories _____________________

self = <tests.integration.test_news_api.TestCategoryAPI object at 0x7532b8391110>
authenticated_client = <rest_framework.test.APIClient object at 0x75327303c1d0>
category = <Category: Test Category>

    def test_list_categories(self, authenticated_client, category):
        """Test listing categories."""
        url = reverse('news:category-list')
        response = authenticated_client.get(url)
    
        assert response.status_code == status.HTTP_200_OK
        assert len(response.data) >= 1
    
>       category_data = response.data[0]
E       KeyError: 0

tests/integration/test_news_api.py:163: KeyError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/categories/
INFO Request completed - GET /api/v1/news/categories/ - 200
____________ TestNewsPermissions.test_unauthenticated_access_denied ____________

self = <tests.integration.test_news_api.TestNewsPermissions object at 0x7532b8393110>
api_client = <rest_framework.test.APIClient object at 0x753272a87e90>
news = <News: Test News Article>

    def test_unauthenticated_access_denied(self, api_client, news):
        """Test that unauthenticated users can't access news API."""
        urls = [
            reverse('news:news-list'),
            reverse('news:news-detail', kwargs={'pk': news.id}),
            reverse('news:category-list'),
            reverse('news:tag-list'),
        ]
    
        for url in urls:
            response = api_client.get(url)
>           assert response.status_code == status.HTTP_401_UNAUTHORIZED
E           assert 429 == 401
E            +  where 429 = <Response status_code=429, "application/json">.status_code
E            +  and   401 = status.HTTP_401_UNAUTHORIZED

tests/integration/test_news_api.py:237: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/news/articles/
INFO Request completed - GET /api/v1/news/articles/ - 429
WARNING Too Many Requests: /api/v1/news/articles/
______________ TestNewsWebhookReceiver.test_receive_valid_webhook ______________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x7532b8750d90>
api_client = <rest_framework.test.APIClient object at 0x7532732823d0>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': '88a491be-cc97-4c03-8ccd-67f7d16972b8', ...}
mock_celery = None

    def test_receive_valid_webhook(self, api_client, webhook_source, sample_webhook_data, mock_celery):
        """Test receiving a valid webhook."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:86: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
__________ TestNewsWebhookReceiver.test_receive_webhook_invalid_json ___________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x7532b8753e10>
api_client = <rest_framework.test.APIClient object at 0x7532727f7190>
webhook_source = <WebhookSource: Test Webhook Source>

    def test_receive_webhook_invalid_json(self, api_client, webhook_source):
        """Test receiving webhook with invalid JSON."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data='invalid json',
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_400_BAD_REQUEST
E       assert 401 == 400
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   400 = status.HTTP_400_BAD_REQUEST

tests/integration/test_webhook_integration.py:115: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_____ TestNewsWebhookReceiver.test_receive_webhook_missing_required_fields _____

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x7532b87514d0>
api_client = <rest_framework.test.APIClient object at 0x753272822d50>
webhook_source = <WebhookSource: Test Webhook Source>, mock_celery = None

    def test_receive_webhook_missing_required_fields(self, api_client, webhook_source, mock_celery):
        """Test receiving webhook with missing required fields."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        invalid_data = {
            'title': 'Test News',
            # Missing content, source
        }
    
        response = api_client.post(
            url,
            data=json.dumps(invalid_data),
            content_type='application/json'
        )
    
        # Should accept the webhook but validation will fail in processing
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:133: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_________ TestNewsWebhookReceiver.test_webhook_signature_verification __________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x7532b87c4ad0>
mock_verify = <MagicMock name='verify_webhook_signature' id='128859529769424'>
api_client = <rest_framework.test.APIClient object at 0x753272cd9450>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': 'bee7e4fb-4cb2-49ea-b9c5-5a68018b38bb', ...}

    @patch('apps.webhooks.utils.verify_webhook_signature')
    def test_webhook_signature_verification(self, mock_verify, api_client, webhook_source, sample_webhook_data):
        """Test webhook signature verification."""
        webhook_source.requires_authentication = True
        webhook_source.save()
    
        # Test with valid signature
        mock_verify.return_value = True
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json',
            HTTP_X_HUB_SIGNATURE_256='sha256=valid_signature'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:152: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Webhook source updated: Test Webhook Source
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
------------------------------ Captured log call -------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source updated: Test Webhook Source
_________________ TestWebhookDashboard.test_webhook_dashboard __________________

self = <tests.integration.test_webhook_integration.TestWebhookDashboard object at 0x7532b87c6550>
authenticated_client = <rest_framework.test.APIClient object at 0x75327336e210>
webhook_source = <WebhookSource: Test Webhook Source>

    def test_webhook_dashboard(self, authenticated_client, webhook_source):
        """Test webhook dashboard endpoint."""
        url = reverse('webhooks:dashboard')
>       response = authenticated_client.get(url)

tests/integration/test_webhook_integration.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:289: in get
    response = super().get(path, data=data, **extra)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:206: in get
    return self.generic('GET', path, **r)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:234: in generic
    return super().generic(
/usr/local/lib/python3.11/site-packages/django/test/client.py:609: in generic
    return self.request(**r)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:286: in request
    return super().request(**kwargs)
/usr/local/lib/python3.11/site-packages/rest_framework/test.py:238: in request
    request = super().request(**kwargs)
/usr/local/lib/python3.11/site-packages/django/test/client.py:891: in request
    self.check_exception(response)
/usr/local/lib/python3.11/site-packages/django/test/client.py:738: in check_exception
    raise exc_value
/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py:55: in inner
    response = get_response(request)
/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py:197: in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
/usr/local/lib/python3.11/site-packages/django/views/decorators/csrf.py:56: in wrapper_view
    return view_func(*args, **kwargs)
/usr/local/lib/python3.11/site-packages/django/views/generic/base.py:104: in view
    return self.dispatch(request, *args, **kwargs)
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:509: in dispatch
    response = self.handle_exception(exc)
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:469: in handle_exception
    self.raise_uncaught_exception(exc)
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:480: in raise_uncaught_exception
    raise exc
/usr/local/lib/python3.11/site-packages/rest_framework/views.py:506: in dispatch
    response = handler(request, *args, **kwargs)
/usr/local/lib/python3.11/site-packages/rest_framework/decorators.py:50: in handler
    return func(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <rest_framework.request.Request: GET '/api/v1/webhooks/dashboard/'>

    @api_view(['GET'])
    @permission_classes([IsAuthenticated])
    @extend_schema(
        summary="Get webhook dashboard data",
        description="Get aggregated webhook statistics for dashboard display."
    )
    def webhook_dashboard(request):
        """
        Get webhook dashboard data.
        """
        # Get recent statistics
        today = timezone.now().date()
        week_ago = today - timezone.timedelta(days=7)
    
        # Overall statistics
        total_sources = WebhookSource.objects.filter(is_active=True).count()
        total_logs = WebhookLog.objects.filter(created_at__date__gte=week_ago).count()
        success_rate = WebhookLog.objects.filter(
            created_at__date__gte=week_ago,
            status='success'
        ).count() / max(total_logs, 1) * 100
    
        # Recent activity
        recent_logs = WebhookLog.objects.filter(
            created_at__date__gte=week_ago
        ).order_by('-created_at')[:10]
    
        # Source statistics
        source_stats = []
        for source in WebhookSource.objects.filter(is_active=True):
            stats = WebhookStatistic.objects.filter(
                source=source,
                date__gte=week_ago
            ).aggregate(
>               total_requests=models.Sum('total_requests'),
                successful_requests=models.Sum('successful_requests'),
                failed_requests=models.Sum('failed_requests')
            )
E           NameError: name 'models' is not defined

apps/webhooks/views.py:404: NameError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/webhooks/dashboard/
ERROR Request failed - GET /api/v1/webhooks/dashboard/ - name 'models' is not defined
Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py", line 197, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/decorators/csrf.py", line 56, in wrapper_view
    return view_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/generic/base.py", line 104, in view
    return self.dispatch(request, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 509, in dispatch
    response = self.handle_exception(exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 480, in raise_uncaught_exception
    raise exc
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/decorators.py", line 50, in handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/app/apps/webhooks/views.py", line 404, in webhook_dashboard
    total_requests=models.Sum('total_requests'),
                   ^^^^^^
NameError: name 'models' is not defined
ERROR Internal Server Error: /api/v1/webhooks/dashboard/
Traceback (most recent call last):
  File "/usr/local/lib/python3.11/site-packages/django/core/handlers/exception.py", line 55, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/core/handlers/base.py", line 197, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/decorators/csrf.py", line 56, in wrapper_view
    return view_func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/views/generic/base.py", line 104, in view
    return self.dispatch(request, *args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 509, in dispatch
    response = self.handle_exception(exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 469, in handle_exception
    self.raise_uncaught_exception(exc)
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 480, in raise_uncaught_exception
    raise exc
  File "/usr/local/lib/python3.11/site-packages/rest_framework/views.py", line 506, in dispatch
    response = handler(request, *args, **kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/rest_framework/decorators.py", line 50, in handler
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/app/apps/webhooks/views.py", line 404, in webhook_dashboard
    total_requests=models.Sum('total_requests'),
                   ^^^^^^
NameError: name 'models' is not defined
INFO Request completed - GET /api/v1/webhooks/dashboard/ - 500
_________ TestWebhookProcessing.test_webhook_processing_task_triggered _________

self = <tests.integration.test_webhook_integration.TestWebhookProcessing object at 0x7532b87c7b50>
mock_task = <MagicMock name='delay' id='128859533725520'>
api_client = <rest_framework.test.APIClient object at 0x753272bbc590>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': 'afb4c94e-8f27-476b-91ba-6718bbccacdc', ...}

    @patch('apps.webhooks.tasks.process_webhook_async.delay')
    def test_webhook_processing_task_triggered(self, mock_task, api_client, webhook_source, sample_webhook_data):
        """Test that webhook processing task is triggered."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:273: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_______________ TestWebhookProcessing.test_webhook_log_creation ________________

self = <tests.integration.test_webhook_integration.TestWebhookProcessing object at 0x7532b8750f90>
api_client = <rest_framework.test.APIClient object at 0x753272bbc250>
webhook_source = <WebhookSource: Test Webhook Source>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': '3f507907-127f-4500-8479-884559ef17a7', ...}
mock_celery = None

    def test_webhook_log_creation(self, api_client, webhook_source, sample_webhook_data, mock_celery):
        """Test that webhook logs are created properly."""
        initial_log_count = WebhookLog.objects.count()
    
        url = reverse('webhooks:news_webhook', kwargs={'source_name': webhook_source.name})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 401 == 200
E        +  where 401 = <JsonResponse status_code=401, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:290: AssertionError
---------------------------- Captured stderr setup -----------------------------
INFO Webhook source created: Test Webhook Source
------------------------------ Captured log setup ------------------------------
INFO     apps.webhooks.signals:signals.py:24 Webhook source created: Test Webhook Source
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/Test Webhook Source/
INFO Request completed - POST /api/v1/webhooks/receive/Test Webhook Source/ - 401
WARNING Unauthorized: /api/v1/webhooks/receive/Test Webhook Source/
_____________ TestSubcategorySerializer.test_serialize_subcategory _____________

self = <tests.unit.test_news_serializers.TestSubcategorySerializer object at 0x7532b877a410>
subcategory = <Subcategory: Test Category - Test Subcategory>

    def test_serialize_subcategory(self, subcategory):
        """Test serializing a subcategory."""
        serializer = SubcategorySerializer(subcategory)
        data = serializer.data
    
        assert data['name'] == subcategory.name
>       assert data['category'] == str(subcategory.category.id)
E       AssertionError: assert UUID('4bd65512-e024-479f-a76b-d65701aaa7a9') == '4bd65512-e024-479f-a76b-d65701aaa7a9'
E        +  where '4bd65512-e024-479f-a76b-d65701aaa7a9' = str(UUID('4bd65512-e024-479f-a76b-d65701aaa7a9'))
E        +    where UUID('4bd65512-e024-479f-a76b-d65701aaa7a9') = <Category: Test Category>.id
E        +      where <Category: Test Category> = <Subcategory: Test Category - Test Subcategory>.category

tests/unit/test_news_serializers.py:60: AssertionError
_________ TestNewsWebhookReceiver.test_receive_webhook_invalid_source __________

self = <tests.integration.test_webhook_integration.TestNewsWebhookReceiver object at 0x7532b87516d0>
api_client = <rest_framework.test.APIClient object at 0x7532732b9ad0>
sample_webhook_data = {'author': 'Webhook Author', 'category_hint': 'test category', 'content': 'This is sample news content received via webhook. It contains enough text to be processed properly.', 'external_id': 'bbec7bc2-12f0-4e92-ac1a-74969f271bdb', ...}

    def test_receive_webhook_invalid_source(self, api_client, sample_webhook_data):
        """Test receiving webhook with invalid source."""
        url = reverse('webhooks:news_webhook', kwargs={'source_name': 'nonexistent'})
    
        response = api_client.post(
            url,
            data=json.dumps(sample_webhook_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_404_NOT_FOUND
E       assert 500 == 404
E        +  where 500 = <JsonResponse status_code=500, "application/json">.status_code
E        +  and   404 = status.HTTP_404_NOT_FOUND

tests/integration/test_webhook_integration.py:103: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/receive/nonexistent/
ERROR Error processing webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 219, in news_webhook
    source = WebhookSource.objects.get(name=source_name, is_active=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
INFO Request completed - POST /api/v1/webhooks/receive/nonexistent/ - 500
ERROR Internal Server Error: /api/v1/webhooks/receive/nonexistent/
------------------------------ Captured log call -------------------------------
ERROR    apps.webhooks.views:views.py:290 Error processing webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 219, in news_webhook
    source = WebhookSource.objects.get(name=source_name, is_active=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
____________ TestWhatsAppWebhook.test_whatsapp_webhook_verification ____________

self = <tests.integration.test_webhook_integration.TestWhatsAppWebhook object at 0x7532b87c4e50>
api_client = <rest_framework.test.APIClient object at 0x7532732d51d0>

    def test_whatsapp_webhook_verification(self, api_client):
        """Test WhatsApp webhook verification."""
        url = reverse('webhooks:whatsapp_webhook')
    
        params = {
            'hub.mode': 'subscribe',
            'hub.challenge': 'test_challenge_string',
            'hub.verify_token': 'test_verify_token'
        }
    
        response = api_client.get(url, params)
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 400 == 200
E        +  where 400 = <HttpResponse status_code=400, "text/html; charset=utf-8">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:183: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - GET /api/v1/webhooks/whatsapp/
INFO Request completed - GET /api/v1/webhooks/whatsapp/ - 400
WARNING Bad Request: /api/v1/webhooks/whatsapp/
__________ TestWhatsAppWebhook.test_whatsapp_webhook_message_receive ___________

self = <tests.integration.test_webhook_integration.TestWhatsAppWebhook object at 0x7532b87c67d0>
api_client = <rest_framework.test.APIClient object at 0x753273237a90>

    def test_whatsapp_webhook_message_receive(self, api_client):
        """Test receiving WhatsApp messages."""
        url = reverse('webhooks:whatsapp_webhook')
    
        whatsapp_data = {
            'object': 'whatsapp_business_account',
            'entry': [{
                'id': 'entry_id',
                'changes': [{
                    'value': {
                        'messaging_product': 'whatsapp',
                        'metadata': {
                            'phone_number_id': 'phone_id'
                        },
                        'messages': [{
                            'id': 'message_id',
                            'from': '5511999999999',
                            'timestamp': '1234567890',
                            'text': {
                                'body': 'Hello from WhatsApp'
                            },
                            'type': 'text'
                        }]
                    },
                    'field': 'messages'
                }]
            }]
        }
    
        response = api_client.post(
            url,
            data=json.dumps(whatsapp_data),
            content_type='application/json'
        )
    
>       assert response.status_code == status.HTTP_200_OK
E       assert 500 == 200
E        +  where 500 = <JsonResponse status_code=500, "application/json">.status_code
E        +  and   200 = status.HTTP_200_OK

tests/integration/test_webhook_integration.py:235: AssertionError
----------------------------- Captured stderr call -----------------------------
INFO Request started - POST /api/v1/webhooks/whatsapp/
ERROR Error processing WhatsApp webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 343, in whatsapp_webhook
    source=WebhookSource.objects.get_or_create(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 916, in get_or_create
    return self.get(**kwargs), False
           ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
INFO Request completed - POST /api/v1/webhooks/whatsapp/ - 500
ERROR Internal Server Error: /api/v1/webhooks/whatsapp/
------------------------------ Captured log call -------------------------------
ERROR    apps.webhooks.views:views.py:366 Error processing WhatsApp webhook: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
Traceback (most recent call last):
  File "/app/apps/webhooks/views.py", line 343, in whatsapp_webhook
    source=WebhookSource.objects.get_or_create(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/manager.py", line 87, in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 916, in get_or_create
    return self.get(**kwargs), False
           ^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 633, in get
    num = len(clone)
          ^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 380, in __len__
    self._fetch_all()
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 1881, in _fetch_all
    self._result_cache = list(self._iterable_class(self))
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/query.py", line 91, in __iter__
    results = compiler.execute_sql(
              ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/models/sql/compiler.py", line 1560, in execute_sql
    cursor = self.connection.cursor()
             ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/utils/asyncio.py", line 26, in inner
    return func(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 330, in cursor
    return self._cursor()
           ^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/site-packages/django/db/backends/base/base.py", line 306, in _cursor
    self.ensure_connection()
  File "/usr/local/lib/python3.11/site-packages/pytest_django/plugin.py", line 798, in _blocking_wrapper
    raise RuntimeError(
RuntimeError: Database access not allowed, use the "django_db" mark, or the "db" or "transactional_db" fixtures to enable it.
=============================== warnings summary ===============================
tests/integration/test_news_api.py:9
  /app/tests/integration/test_news_api.py:9: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_news_api.py:151
  /app/tests/integration/test_news_api.py:151: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_news_api.py:195
  /app/tests/integration/test_news_api.py:195: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_news_api.py:222
  /app/tests/integration/test_news_api.py:222: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:14
  /app/tests/integration/test_webhook_integration.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:72
  /app/tests/integration/test_webhook_integration.py:72: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:167
  /app/tests/integration/test_webhook_integration.py:167: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:238
  /app/tests/integration/test_webhook_integration.py:238: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/integration/test_webhook_integration.py:258
  /app/tests/integration/test_webhook_integration.py:258: PytestUnknownMarkWarning: Unknown pytest.mark.integration - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.integration

tests/unit/test_classification_models.py:14
  /app/tests/unit/test_classification_models.py:14: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:80
  /app/tests/unit/test_classification_models.py:80: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:119
  /app/tests/unit/test_classification_models.py:119: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:172
  /app/tests/unit/test_classification_models.py:172: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_classification_models.py:196
  /app/tests/unit/test_classification_models.py:196: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:13
  /app/tests/unit/test_news_models.py:13: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:49
  /app/tests/unit/test_news_models.py:49: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:84
  /app/tests/unit/test_news_models.py:84: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:110
  /app/tests/unit/test_news_models.py:110: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_models.py:209
  /app/tests/unit/test_news_models.py:209: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:15
  /app/tests/unit/test_news_serializers.py:15: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:50
  /app/tests/unit/test_news_serializers.py:50: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:65
  /app/tests/unit/test_news_serializers.py:65: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

tests/unit/test_news_serializers.py:79
  /app/tests/unit/test_news_serializers.py:79: PytestUnknownMarkWarning: Unknown pytest.mark.unit - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.unit

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html

---------- coverage: platform linux, python 3.11.13-final-0 ----------
Name                                             Stmts   Miss  Cover   Missing
------------------------------------------------------------------------------
apps/__init__.py                                     0      0   100%
apps/authentication/__init__.py                      0      0   100%
apps/authentication/admin.py                        34      4    88%   80-83
apps/authentication/apps.py                         10      0   100%
apps/authentication/migrations/0001_initial.py      11     11     0%   3-19
apps/authentication/migrations/__init__.py           0      0   100%
apps/authentication/models.py                       63      5    92%   70, 108-111
apps/authentication/serializers.py                  96     30    69%   50-52, 55-61, 85-88, 100-103, 106-108, 111-114, 154-157, 168-171
apps/authentication/urls.py                         19      1    95%   154
apps/authentication/views.py                       104     36    65%   63, 87-91, 108-121, 131, 134-136, 143, 150, 159, 166, 173, 180, 187, 202-203, 214-230
apps/classification/__init__.py                      0      0   100%
apps/classification/admin.py                       144     63    56%   54-61, 71-72, 77-78, 83-88, 142-152, 162-163, 168-169, 218-219, 224-231, 239, 246, 250, 256-260, 265-266, 303-304, 309, 317-318, 323-324, 329-330, 347-354, 362, 366
apps/classification/apps.py                          7      0   100%
apps/classification/classifier.py                  225    170    24%   26-27, 74-75, 79, 88-97, 103-126, 132-155, 161-210, 216-237, 243-283, 289-374, 380-441, 447-465, 471-482
apps/classification/migrations/0001_initial.py       8      8     0%   3-16
apps/classification/migrations/__init__.py           0      0   100%
apps/classification/models.py                      162      1    99%   284
apps/classification/serializers.py                  87     26    70%   117-122, 140-148, 159-163, 173-176, 186-190
apps/classification/signals.py                      38      6    84%   33-39, 74
apps/classification/tasks.py                       168    146    13%   24-143, 151-208, 216-280, 288-309, 317-340, 348-367, 375-414
apps/classification/urls.py                         12      0   100%
apps/classification/views.py                       168     74    56%   70-87, 103-125, 156-173, 186-208, 234, 246-256, 265-271, 297, 306-318, 354-374, 388-397, 412-448, 471-473, 485-487
apps/news/__init__.py                                0      0   100%
apps/news/admin.py                                  91     20    78%   22-24, 39-41, 116-117, 123-124, 132-133, 141-142, 150-151, 168-169, 185, 189
apps/news/apps.py                                    7      0   100%
apps/news/filters.py                                62     18    71%   103-107, 113-116, 122-128, 158-161, 167-169, 204-207
apps/news/migrations/0001_initial.py                11     11     0%   3-17
apps/news/migrations/__init__.py                     0      0   100%
apps/news/models.py                                121      1    99%   224
apps/news/pagination.py                             15      1    93%   44
apps/news/serializers.py                            92      0   100%
apps/news/signals.py                                39      3    92%   38-40
apps/news/tasks.py                                  93     93     0%   4-221
apps/news/urls.py                                   12      0   100%
apps/news/views.py                                 149     33    78%   62, 268-276, 285-329
apps/notifications/__init__.py                       0      0   100%
apps/notifications/admin.py                        141     56    60%   49-56, 66-67, 72-73, 78-84, 125-126, 131, 137-138, 143-144, 178, 184-185, 190-191, 245, 250, 255, 260-261, 266, 272, 276, 282-295, 300-301, 319-326, 334, 338, 342
apps/notifications/apps.py                           7      0   100%
apps/notifications/migrations/0001_initial.py        9      9     0%   3-18
apps/notifications/migrations/__init__.py            0      0   100%
apps/notifications/models.py                       202     64    68%   60, 64-66, 70-71, 75-76, 81-83, 145, 149-151, 198, 202-217, 221-223, 309, 313-323, 327-334, 338-352, 356-367, 404
apps/notifications/providers.py                    140    106    24%   21, 31, 41, 50-56, 62-101, 107-132, 144-167, 174, 186-217, 223, 235-255, 261, 276-278, 284, 301-305, 313-318, 325-330
apps/notifications/serializers.py                  129     55    57%   54-75, 149-159, 163-165, 192-199, 203-207, 211-219, 230-233, 245-249, 259-263
apps/notifications/signals.py                       37     25    32%   16-24, 33-39, 47-54, 70-93
apps/notifications/tasks.py                        194    171    12%   25-133, 141-211, 219-253, 261-353, 361-383, 391-463, 471-489
apps/notifications/urls.py                          12      0   100%
apps/notifications/views.py                        211    119    44%   70-91, 104-120, 155-160, 166-169, 178-216, 246, 255-269, 296-303, 312-335, 344-355, 377, 393-431, 444-470, 484-536, 560-562, 574-576
apps/webhooks/__init__.py                            0      0   100%
apps/webhooks/admin.py                             105     40    62%   50-57, 67-68, 73-74, 79-85, 136, 140, 144, 150-161, 166-167, 184, 189, 193, 210-217, 225, 229, 233
apps/webhooks/apps.py                                7      0   100%
apps/webhooks/migrations/0001_initial.py             7      7     0%   3-13
apps/webhooks/migrations/__init__.py                 0      0   100%
apps/webhooks/models.py                            124     19    85%   124, 128-132, 136-139, 143-146, 173, 202, 207-209
apps/webhooks/serializers.py                        81     27    67%   109-111, 115-119, 123-127, 131-135, 148-151, 163-167
apps/webhooks/signals.py                            28      1    96%   68
apps/webhooks/tasks.py                             151    131    13%   26-174, 182-237, 245-264, 272-302, 310-331
apps/webhooks/urls.py                                9      0   100%
apps/webhooks/utils.py                             121     86    29%   20, 51-53, 69, 76-78, 85-125, 132-158, 165-206, 213-215, 228-242, 249-261, 268-277
apps/webhooks/views.py                             138     28    80%   152-176, 221, 228, 236, 250-283, 331-332, 363, 409-414
------------------------------------------------------------------------------
TOTAL                                             3901   1705    56%
Coverage HTML written to dir test_results/coverage_20250709_213336

=========================== short test summary info ============================
FAILED tests/test_authentication.py::TestUserModel::test_superuser_creation
FAILED tests/test_authentication.py::TestAPIKeyModel::test_api_key_str - Asse...
FAILED tests/test_authentication.py::TestAuthenticationAPI::test_user_registration
FAILED tests/test_authentication.py::TestAuthenticationAPI::test_user_profile_get
FAILED tests/test_authentication.py::TestAPIKeyAuthentication::test_api_key_authentication
FAILED tests/test_authentication_fixed.py::TestUserModel::test_superuser_creation
FAILED tests/test_authentication_fixed.py::TestAPIKeyModel::test_api_key_str
FAILED tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_registration
FAILED tests/test_authentication_fixed.py::TestAuthenticationAPI::test_user_profile_get
FAILED tests/test_authentication_fixed.py::TestAPIKeyAuthentication::test_api_key_authentication
FAILED tests/test_news.py::TestNewsAPI::test_news_list_public - django.urls.e...
FAILED tests/test_news.py::TestNewsAPI::test_news_detail_public - django.urls...
FAILED tests/test_news.py::TestNewsAPI::test_news_create_authenticated - djan...
FAILED tests/test_news.py::TestNewsAPI::test_news_create_unauthenticated - dj...
FAILED tests/test_news.py::TestNewsAPI::test_news_update_authenticated - djan...
FAILED tests/test_news.py::TestNewsAPI::test_news_delete_authenticated - djan...
FAILED tests/test_news.py::TestNewsAPI::test_news_filter_by_category - django...
FAILED tests/test_news.py::TestNewsAPI::test_news_search - django.urls.except...
FAILED tests/test_news.py::TestNewsAPI::test_news_urgent_filter - django.urls...
FAILED tests/test_news.py::TestCategoryAPI::test_category_create_user - asser...
FAILED tests/test_news.py::TestTagAPI::test_tag_list - assert 429 == 200
FAILED tests/test_news.py::TestTagAPI::test_tag_autocomplete - assert 429 == 200
FAILED tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_list_user
FAILED tests/test_webhooks.py::TestWebhookReceiver::test_webhook_receive_async_processing
FAILED tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_list_user
FAILED tests/integration/test_news_api.py::TestNewsAPI::test_list_news_unauthenticated
FAILED tests/integration/test_news_api.py::TestNewsAPI::test_create_news - As...
FAILED tests/integration/test_news_api.py::TestCategoryAPI::test_list_categories
FAILED tests/integration/test_news_api.py::TestNewsPermissions::test_unauthenticated_access_denied
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_valid_webhook
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_json
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_missing_required_fields
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_webhook_signature_verification
FAILED tests/integration/test_webhook_integration.py::TestWebhookDashboard::test_webhook_dashboard
FAILED tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_processing_task_triggered
FAILED tests/integration/test_webhook_integration.py::TestWebhookProcessing::test_webhook_log_creation
FAILED tests/unit/test_news_serializers.py::TestSubcategorySerializer::test_serialize_subcategory
FAILED tests/integration/test_webhook_integration.py::TestNewsWebhookReceiver::test_receive_webhook_invalid_source
FAILED tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_verification
FAILED tests/integration/test_webhook_integration.py::TestWhatsAppWebhook::test_whatsapp_webhook_message_receive
ERROR tests/test_news.py::TestCategoryAPI::test_category_create_admin - djang...
ERROR tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_list_admin
ERROR tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_create_admin
ERROR tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_update_admin
ERROR tests/test_webhooks.py::TestWebhookAPI::test_webhook_source_delete_admin
ERROR tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_list_admin
ERROR tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_filter_by_source
ERROR tests/test_webhooks.py::TestWebhookLogAPI::test_webhook_log_filter_by_status
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_filter_news_by_category
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_search_news - dja...
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_get_related_news
ERROR tests/integration/test_news_api.py::TestNewsAPI::test_advanced_search
============ 40 failed, 86 passed, 23 warnings, 12 errors in 37.92s ============
[2025-07-09 21:34:56] ✅ PASSED: All Tests with Coverage
[2025-07-09 21:34:56] Starting: Django Test Runner
Found 0 test(s).
Skipping setup of unused database(s): default.
WARNING NLTK stopwords not available, using default Portuguese stopwords
System check identified no issues (0 silenced).

----------------------------------------------------------------------
Ran 0 tests in 0.000s

OK
[2025-07-09 21:35:01] ✅ PASSED: Django Test Runner
[2025-07-09 21:35:01] === TEST SUMMARY ===
[2025-07-09 21:35:01] Total Tests: 8
[2025-07-09 21:35:01] Passed: 8
[2025-07-09 21:35:01] Failed: 0
[2025-07-09 21:35:01] Success Rate: %
